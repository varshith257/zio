"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[59043],{15680:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>g});var t=a(96540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function r(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var c=t.createContext({}),o=function(e){var n=t.useContext(c),a=n;return e&&(a="function"==typeof e?e(n):s(s({},n),e)),a},p=function(e){var n=o(e.components);return t.createElement(c.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,l=e.originalType,c=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),m=o(a),h=i,g=m["".concat(c,".").concat(h)]||m[h]||d[h]||l;return a?t.createElement(g,s(s({ref:n},p),{},{components:a})):t.createElement(g,s({ref:n},p))}));function g(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=a.length,s=new Array(l);s[0]=h;var r={};for(var c in n)hasOwnProperty.call(n,c)&&(r[c]=n[c]);r.originalType=e,r[m]="string"==typeof e?e:i,s[1]=r;for(var o=2;o<l;o++)s[o]=a[o];return t.createElement.apply(null,s)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},51751:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>o});var t=a(58168),i=(a(96540),a(15680));const l={id:"basic-building-blocks",title:"Basic Building Blocks"},s=void 0,r={unversionedId:"zio-schema/basic-building-blocks",id:"zio-schema/basic-building-blocks",title:"Basic Building Blocks",description:"To get started, first we need to understand that a ZIO Schema is basically built-up from these three",source:"@site/docs/zio-schema/basic-building-blocks.md",sourceDirName:"zio-schema",slug:"/zio-schema/basic-building-blocks",permalink:"/zio-schema/basic-building-blocks",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/basic-building-blocks.md",tags:[],version:"current",frontMatter:{id:"basic-building-blocks",title:"Basic Building Blocks"},sidebar:"ecosystem-sidebar",previous:{title:"Use cases",permalink:"/zio-schema/use-cases"},next:{title:"Standard Type Reference",permalink:"/zio-schema/standard-type-reference"}},c={},o=[{value:"Primitives",id:"primitives",level:2},{value:"Fail",id:"fail",level:2},{value:"Collections",id:"collections",level:2},{value:"Sequence",id:"sequence",level:3},{value:"Map",id:"map",level:3},{value:"Set",id:"set",level:3},{value:"Records",id:"records",level:2},{value:"Enumerations",id:"enumerations",level:2},{value:"Optionals",id:"optionals",level:2},{value:"Either",id:"either",level:2},{value:"Tuple",id:"tuple",level:2}],p={toc:o},m="wrapper";function d(e){let{components:n,...a}=e;return(0,i.yg)(m,(0,t.A)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"To get started, first we need to understand that a ZIO Schema is basically built-up from these three\nsealed traits: ",(0,i.yg)("inlineCode",{parentName:"p"},"Record[R]"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Enum[A]")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Sequence[Col, Elem]"),", along with the case class ",(0,i.yg)("inlineCode",{parentName:"p"},"Primitive[A]"),". Every other type is just a specialisation of one of these (or not relevant to get you started)."),(0,i.yg)("p",null,"The core data type of ZIO Schema is a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema[A]")," which is ",(0,i.yg)("strong",{parentName:"p"},"invariant in ",(0,i.yg)("inlineCode",{parentName:"strong"},"A"))," by necessity, because a Schema allows us to derive operations that produce an ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," but also operations that consume an ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," and that imposes limitations on the types of ",(0,i.yg)("strong",{parentName:"p"},"transformation operators")," and ",(0,i.yg)("strong",{parentName:"p"},"composition operators")," that we can provide based on a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema"),"."),(0,i.yg)("p",null,"It looks kind of like this (simplified):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait Schema[A] { self =>\n  def zip[B](that: Schema[B]): Schema[(A, B)]\n\n  def transform[B](f: A => B, g: B => A): Schema[B]\n}\n")),(0,i.yg)("h2",{id:"primitives"},"Primitives"),(0,i.yg)("p",null,"To describe scalar data type ",(0,i.yg)("inlineCode",{parentName:"p"},"A"),", we use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Primitive[A]")," data type which basically is a wrapper around ",(0,i.yg)("inlineCode",{parentName:"p"},"StandardType"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"case class Primitive[A](standardType: StandardType[A]) extends Schema[A]\n")),(0,i.yg)("p",null,"Primitive values are represented using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Primitive[A]")," type class and represent the elements that we cannot further define through other means. If we visualize our data structure as a tree, primitives are the leaves."),(0,i.yg)("p",null,"For a list of all standard types (and therefore primitive types) with built-in support, please see the ",(0,i.yg)("a",{parentName:"p",href:"/zio-schema/standard-type-reference"},"standard type reference")),(0,i.yg)("p",null,"Inside ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema"),"'s companion object, we have an implicit conversion from ",(0,i.yg)("inlineCode",{parentName:"p"},"StandardType[A]")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema[A]"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n   implicit def primitive[A](implicit standardType: StandardType[A]): Schema[A] = ???\n}\n")),(0,i.yg)("p",null,"So we can easily create a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema")," for a primitive type ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," either by calling ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.primitive[A]")," or by calling ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.apply[A]"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"val intSchema1: Schema[Int] = Schema[Int]\nval intSchema2: Schema[Int] = Schema.primitive[Int] \n")),(0,i.yg)("h2",{id:"fail"},"Fail"),(0,i.yg)("p",null,"To represents the absence of schema information for the given ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," type, we can use ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.fail")," constructor, which creates the following schema:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  case class Fail[A](\n    message: String,\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Schema[A]\n}\n")),(0,i.yg)("h2",{id:"collections"},"Collections"),(0,i.yg)("h3",{id:"sequence"},"Sequence"),(0,i.yg)("p",null,"Often we have a type that is a collection of elements. For example, we might have a ",(0,i.yg)("inlineCode",{parentName:"p"},"List[User]"),". This is called a ",(0,i.yg)("inlineCode",{parentName:"p"},"Sequence")," and is represented using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Sequence[Col, Elem, I]")," type class:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed trait Collection[Col, Elem] extends Schema[Col]\n  \n  final case class Sequence[Col, Elem, I](\n      elementSchema: Schema[Elem],\n      fromChunk: Chunk[Elem] => Col,\n      toChunk: Col => Chunk[Elem],\n      override val annotations: Chunk[Any] = Chunk.empty,\n      identity: I\n    ) extends Collection[Col, Elem]\n}\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Sequence")," can be anything that can be isomorphic to a list. "),(0,i.yg)("p",null,"Here is an example schema for list of ",(0,i.yg)("inlineCode",{parentName:"p"},"Person"),"s:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n}\n\nval personListSchema: Schema[List[Person]] =\n  Sequence[List[Person], Person, String](\n    elementSchema = Schema[Person],\n    fromChunk = _.toList,\n    toChunk = i => Chunk.fromIterable(i),\n    annotations = Chunk.empty,\n    identity = "List"\n  )\n')),(0,i.yg)("p",null,"ZIO Schema has ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.list[A]"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.chunk[A]")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.vector[A]")," constructors that create ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema[List[A]]"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema[Chunk[A]]")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema[Vector[A]]")," for us:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n  \n  implicit val listSchema:   Schema[List[Person]]   = Schema.list[Person]\n  implicit val chunkSchema:  Schema[Chunk[Person]]  = Schema.chunk[Person]\n  implicit val vectorSchema: Schema[Vector[Person]] = Schema.vector[Person]\n}\n")),(0,i.yg)("h3",{id:"map"},"Map"),(0,i.yg)("p",null,"Likewise, we can have a type that is a map of keys to values. ZIO Schema represents this using the following type class:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed trait Collection[Col, Elem] extends Schema[Col]\n\n  case class Map[K, V](\n    keySchema: Schema[K],\n    valueSchema: Schema[V],\n    override val annotations: Chunk[Any] = Chunk.empty\n  ) extends Collection[scala.collection.immutable.Map[K, V], (K, V)]\n}\n")),(0,i.yg)("p",null,"It stores the key and value schemas. Like ",(0,i.yg)("inlineCode",{parentName:"p"},"Sequence"),", instead of using ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," directly, we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.map[K, V]")," constructor:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n  \n  implicit val mapSchema: Schema[scala.collection.immutable.Map[String, Person]] = \n    Schema.map[String, Person]\n}\n")),(0,i.yg)("h3",{id:"set"},"Set"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Set")," type class is similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"Sequence")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Map"),". It is used to represent a schema for a set of elements:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed trait Collection[Col, Elem] extends Schema[Col]\n\n  case class Set[A](\n    elementSchema: Schema[A],\n    override val annotations: Chunk[Any] = Chunk.empty\n  ) extends Collection[scala.collection.immutable.Set[A], A]\n}\n")),(0,i.yg)("p",null,"To create a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema")," for a ",(0,i.yg)("inlineCode",{parentName:"p"},"Set[A]"),", we can use the above type class directly or use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.set[A]")," constructor:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.schema._\nimport zio.schema.Schema._\n  \ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n  \n  implicit val setSchema: Schema[scala.collection.immutable.Set[Person]] = \n    Schema.set[Person]\n}\n")),(0,i.yg)("h2",{id:"records"},"Records"),(0,i.yg)("p",null,"Our data structures usually are composed of a lot of types. For example, we might have a ",(0,i.yg)("inlineCode",{parentName:"p"},"User")," type that has a ",(0,i.yg)("inlineCode",{parentName:"p"},"name")," field, an ",(0,i.yg)("inlineCode",{parentName:"p"},"age")," field, an ",(0,i.yg)("inlineCode",{parentName:"p"},"address")," field, and a ",(0,i.yg)("inlineCode",{parentName:"p"},"friends")," field."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"case class User(name: String, age: Int, address: Address, friends: List[User])\n")),(0,i.yg)("p",null,"This is called a ",(0,i.yg)("strong",{parentName:"p"},"product type")," in functional programming. The equivalent of a product type in ZIO Schema is called a record."),(0,i.yg)("p",null,"In ZIO Schema such a record would be represented using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Record[R]")," typeclass:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed trait Field[R, A] {\n    type Field <: Singleton with String\n    def name: Field\n    def schema: Schema[A]\n  }\n\n  sealed trait Record[R] extends Schema[R] {\n    def id: TypeId\n    def fields: Chunk[Field[_]]\n    def construct(fieldValues: Chunk[Any]): Either[String, R]\n  }\n}\n")),(0,i.yg)("p",null,"ZIO Schema has specialized record types for case classes, called ",(0,i.yg)("inlineCode",{parentName:"p"},"CaseClass1[A, Z]"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"CaseClass2[A1, A2, Z]"),", ..., ",(0,i.yg)("inlineCode",{parentName:"p"},"CaseClass22"),". Here is the definition of ",(0,i.yg)("inlineCode",{parentName:"p"},"apply")," method of ",(0,i.yg)("inlineCode",{parentName:"p"},"CaseClass1")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"CaseClass2"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait CaseClass1[A, Z] extends Record[Z]\n\nobject CaseClass1 {\n  def apply[A, Z](\n    id0: TypeId,\n    field0: Field[Z, A],\n    defaultConstruct0: A => Z,\n    annotations0: Chunk[Any] = Chunk.empty\n  ): CaseClass1[A, Z] = ???\n}\n\nobject CaseClass2 {\n  def apply[A1, A2, Z](\n    id0: TypeId,\n    field01: Field[Z, A1],\n    field02: Field[Z, A2],\n    construct0: (A1, A2) => Z,\n    annotations0: Chunk[Any] = Chunk.empty\n  ): CaseClass2[A1, A2, Z] = ???\n}\n")),(0,i.yg)("p",null,"As we can see, they take a ",(0,i.yg)("inlineCode",{parentName:"p"},"TypeId"),", a number of fields of type ",(0,i.yg)("inlineCode",{parentName:"p"},"Field"),", and a construct function. The ",(0,i.yg)("inlineCode",{parentName:"p"},"TypeId")," is used to uniquely identify the type. The ",(0,i.yg)("inlineCode",{parentName:"p"},"Field")," is used to store the name of the field and the schema of the field. The ",(0,i.yg)("inlineCode",{parentName:"p"},"construct")," is used to construct the type from the field values."),(0,i.yg)("p",null,"Here is an example of defining schema for ",(0,i.yg)("inlineCode",{parentName:"p"},"Person")," data type:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.schema._\n\nfinal case class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] =\n    Schema.CaseClass2[String, Int, Person](\n      id0 = TypeId.fromTypeName("Person"),\n      field01 = \n        Schema.Field(\n          name0 = "name",\n          schema0 = Schema[String],\n          get0 = _.name,\n          set0 = (p, x) => p.copy(name = x)\n        ),\n      field02 = \n        Schema.Field(\n          name0 = "age",\n          schema0 = Schema[Int],\n          get0 = _.age,\n          set0 = (person, age) => person.copy(age = age)\n        ),\n      construct0 = (name, age) => Person(name, age),\n    )\n}\n')),(0,i.yg)("p",null,"There is also the ",(0,i.yg)("inlineCode",{parentName:"p"},"GenericRecord")," which is used to either ad-hoc records or records that have more than 22 fields:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed case class GenericRecord(\n    id: TypeId,\n    fieldSet: FieldSet,\n    override val annotations: Chunk[Any] = Chunk.empty\n  ) extends Record[ListMap[String, _]]\n}\n")),(0,i.yg)("h2",{id:"enumerations"},"Enumerations"),(0,i.yg)("p",null,"Other times, you might have a type that represents a list of different types. For example, we might have a type, like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait PaymentMethod \n\nobject PaymentMethod {\n  final case class CreditCard(number: String, expirationMonth: Int, expirationYear: Int) extends PaymentMethod\n  final case class WireTransfer(accountNumber: String, bankCode: String) extends PaymentMethod\n}\n")),(0,i.yg)("p",null,"In functional programming, this kind of type is called a ",(0,i.yg)("strong",{parentName:"p"},"sum type"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"In Scala 2, this is called a ",(0,i.yg)("strong",{parentName:"li"},"sealed trait"),"."),(0,i.yg)("li",{parentName:"ul"},"In Scala3, this is called an ",(0,i.yg)("strong",{parentName:"li"},"enum"),".")),(0,i.yg)("p",null,"In ZIO Schema we call these types ",(0,i.yg)("inlineCode",{parentName:"p"},"enumeration")," types, and they are represented using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Enum[A]")," type class."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed trait Enum[Z] extends Schema[Z]\n}\n")),(0,i.yg)("p",null,"It has specialized types ",(0,i.yg)("inlineCode",{parentName:"p"},"Enum1[A, Z]"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Enum2[A1, A2, Z]"),", ..., ",(0,i.yg)("inlineCode",{parentName:"p"},"Enum22[A1, A2, ..., A22, Z]")," for enumerations with 1, 2, ..., 22 cases. Here is the definition of ",(0,i.yg)("inlineCode",{parentName:"p"},"Enum1")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Enum2"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"  sealed case class Enum1[A, Z](\n    id: TypeId,\n    case1: Case[Z, A],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Enum[Z]\n\n  sealed case class Enum2[A1, A2, Z](\n    id: TypeId,\n    case1: Case[Z, A1],\n    case2: Case[Z, A2],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Enum[Z]\n\n  // Enum3, Enum4, ..., Enum22\n}\n")),(0,i.yg)("p",null,"If the enumeration has more than 22 cases, we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"EnumN")," type class:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  sealed case class EnumN[Z, C <: CaseSet.Aux[Z]](\n    id: TypeId,\n    caseSet: C,\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Enum[Z]\n}\n")),(0,i.yg)("p",null,"It has a simple constructor called ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.enumeration"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  def enumeration[A, C <: CaseSet.Aux[A]](id: TypeId, caseSet: C): Schema[A] = ???\n}\n")),(0,i.yg)("h2",{id:"optionals"},"Optionals"),(0,i.yg)("p",null,"To create a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema")," for optional values, we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Optional")," type class:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  case class Optional[A](\n    schema: Schema[A],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Schema[Option[A]]\n}\n")),(0,i.yg)("p",null,"Using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.option[A]")," constructor, makes it easier to do so:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"val option: Schema[Option[Person]] = Schema.option[Person]\n")),(0,i.yg)("h2",{id:"either"},"Either"),(0,i.yg)("p",null,"Here is the same but for ",(0,i.yg)("inlineCode",{parentName:"p"},"Either"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  case class Either[A, B](\n    left: Schema[A],\n    right: Schema[B],\n    annotations: Chunk[Any] = Chunk.empty\n  ) extends Schema[scala.util.Either[A, B]]\n}\n")),(0,i.yg)("p",null,"We can use ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.either[A, B]")," to create a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema")," for ",(0,i.yg)("inlineCode",{parentName:"p"},"scala.util.Either[A, B]"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"val eitherPersonSchema: Schema[scala.util.Either[String, Person]] = \n  Schema.either[String, Person]\n")),(0,i.yg)("h2",{id:"tuple"},"Tuple"),(0,i.yg)("p",null,"Each schema has a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema#zip")," operator that allows us to combine two schemas and create a schema for a tuple of the two types:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  def zip[B](that: Schema[B]): Schema[(A, B)] = \n    Schema.Tuple2(self, that)\n}\n")),(0,i.yg)("p",null,"It is implemented using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema.Tuple2")," type class:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  final case class Tuple2[A, B](\n    left: Schema[A],\n    right: Schema[B], \n    annotations: Chunk[Any] = Chunk.em\n    pty\n  ) extends Schema[(A, B)] \n}\n")),(0,i.yg)("p",null,"ZIO Schema also provides implicit conversions for tuples of arity 2, 3, ..., 22:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"object Schema {\n  implicit def tuple2[A, B](implicit c1: Schema[A], c2: Schema[B]): Schema[(A, B)] =\n    c1.zip(c2)\n\n  implicit def tuple3[A, B, C](implicit c1: Schema[A], c2: Schema[B], c3: Schema[C]): Schema[(A, B, C)] =\n    c1.zip(c2).zip(c3).transform({ case ((a, b), c) => (a, b, c) }, { case (a, b, c) => ((a, b), c) })\n\n  // tuple3, tuple4, ..., tuple22\n}\n")),(0,i.yg)("p",null,"So we can easily create a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema")," for a tuple of n elements, just by calling ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema[(A1, A2, ..., An)]"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.schema._\n\nval tuple2: Schema[(String, Int)]          = Schema[(String, Int)]\nval tuple3: Schema[(String, Int, Boolean)] = Schema[(String, Int, Boolean)]\n")))}d.isMDXComponent=!0}}]);