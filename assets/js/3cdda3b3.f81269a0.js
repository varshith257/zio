"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[50484],{15680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>m});var a=t(96540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(t),c=r,m=u["".concat(s,".").concat(c)]||u[c]||g[c]||o;return t?a.createElement(m,i(i({ref:n},d),{},{components:t})):a.createElement(m,i({ref:n},d))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},32396:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(58168),r=(t(96540),t(15680));const o={id:"build-a-restful-webservice",title:"Tutorial: How to Build a RESTful Web Service",sidebar_label:"Building a RESTful Web Service"},i=void 0,l={unversionedId:"guides/tutorials/build-a-restful-webservice",id:"guides/tutorials/build-a-restful-webservice",title:"Tutorial: How to Build a RESTful Web Service",description:"ZIO provides good support for building RESTful web services. Using Service Pattern, we can build web services that are modular and easy to test and maintain. On the other hand, we have several powerful official and community libraries that can help us to work with JSON data types, and databases and also work with HTTP protocol.",source:"@site/docs/guides/tutorials/build-a-restful-webservice.md",sourceDirName:"guides/tutorials",slug:"/guides/tutorials/build-a-restful-webservice",permalink:"/guides/tutorials/build-a-restful-webservice",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md",tags:[],version:"current",frontMatter:{id:"build-a-restful-webservice",title:"Tutorial: How to Build a RESTful Web Service",sidebar_label:"Building a RESTful Web Service"},sidebar:"guides-sidebar",previous:{title:"Debugging a ZIO Application",permalink:"/guides/tutorials/debug-a-zio-application"},next:{title:"Building a GraphQL Web Service",permalink:"/guides/tutorials/build-a-graphql-webservice"}},s={},p=[{value:"Installation",id:"installation",level:2},{value:"Introduction to The <code>Route</code> Data Type",id:"introduction-to-the-route-data-type",level:2},{value:"Modeling Http Applications",id:"modeling-http-applications",level:2},{value:"Creation of a <code>Handler</code>",id:"creation-of-a-handler",level:3},{value:"Combining Handlers",id:"combining-handlers",level:3},{value:"Built-in <code>Request</code> and <code>Response</code> Data Types",id:"built-in-request-and-response-data-types",level:2},{value:"Creating HTTP Server",id:"creating-http-server",level:2},{value:"Greeting App",id:"greeting-app",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p},u="wrapper";function g(e){let{components:n,...t}=e;return(0,r.yg)(u,(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"ZIO provides good support for building RESTful web services. Using ",(0,r.yg)("em",{parentName:"p"},"Service Pattern"),", we can build web services that are modular and easy to test and maintain. On the other hand, we have several powerful official and community libraries that can help us to work with JSON data types, and databases and also work with HTTP protocol."),(0,r.yg)("p",null,"In this tutorial, we will learn how to build a RESTful web service using ZIO. The corresponding source code for this tutorial is available on ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/zio/zio-quickstarts"},"GitHub"),". If you haven't read the ",(0,r.yg)("a",{parentName:"p",href:"/guides/quickstarts/restful-webservice"},"ZIO Quickstart: Building RESTful Web Service")," yet, we recommend you read it first and download and run the source code, before reading this tutorial."),(0,r.yg)("h2",{id:"installation"},"Installation"),(0,r.yg)("p",null,"We need to add the following dependencies to our project:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies ++= Seq(\n  "dev.zio"  %% "zio-http" % "3.0.0-RC6"\n)\n')),(0,r.yg)("p",null,"For this tutorial, we will be using the ",(0,r.yg)("em",{parentName:"p"},(0,r.yg)("a",{parentName:"em",href:"https://zio.dev/zio-http/"},"ZIO HTTP"))," library, which is a library for building HTTP applications using ZIO."),(0,r.yg)("h2",{id:"introduction-to-the-route-data-type"},"Introduction to The ",(0,r.yg)("inlineCode",{parentName:"h2"},"Route")," Data Type"),(0,r.yg)("p",null,"Before we start to build a RESTful web service, we need to understand the ",(0,r.yg)("inlineCode",{parentName:"p"},"Route")," data type. It is a data type that models a route in an HTTP application."),(0,r.yg)("p",null,"We can think of the ",(0,r.yg)("inlineCode",{parentName:"p"},"Route[Env, Err]")," as a description of an HTTP route that accepts a ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," that matches the route pattern and returns a ",(0,r.yg)("inlineCode",{parentName:"p"},"Response"),". It can use the environment of type ",(0,r.yg)("inlineCode",{parentName:"p"},"Env")," and may fail with an error of type ",(0,r.yg)("inlineCode",{parentName:"p"},"Err"),"."),(0,r.yg)("p",null,"A simple ",(0,r.yg)("inlineCode",{parentName:"p"},"Route")," can be defined as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\n\nval helloRoute: Route[Any, Nothing] =\n  Method.GET / "hello" -> handler(Response.text("Hello, world!"))\n')),(0,r.yg)("p",null,"We can say that ",(0,r.yg)("inlineCode",{parentName:"p"},"Route[Any, Nothing]")," is a function that takes a ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," and returns a ",(0,r.yg)("inlineCode",{parentName:"p"},"Response"),". It doesn't require any services from the environment and won't fail."),(0,r.yg)("p",null,"Having multiple routes, we can collect them into a single ",(0,r.yg)("inlineCode",{parentName:"p"},"Routes")," data type:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\n\nval routes: Routes[Any, Nothing] =\n  Routes(\n    Method.GET / "hello" -> handler(Response.text("Hello, world!")),\n    Method.GET / "greet" -> handler(Response.text("Hello, ZIO!"))\n  )\n')),(0,r.yg)("p",null,"Finally, we can serve the routes using the ",(0,r.yg)("inlineCode",{parentName:"p"},"Server.serve")," method:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.http._\n\nobject MainApp extends ZIOAppDefault {\n  def run = Server.serve(routes).provide(Server.default)\n}\n")),(0,r.yg)("h2",{id:"modeling-http-applications"},"Modeling Http Applications"),(0,r.yg)("p",null,"Let's try to model some HTTP applications using the ",(0,r.yg)("inlineCode",{parentName:"p"},"Route")," data type. So first, we are going to learn some basic ",(0,r.yg)("inlineCode",{parentName:"p"},"Route")," constructors and how to combine them to build more complex HTTP applications."),(0,r.yg)("h3",{id:"creation-of-a-handler"},"Creation of a ",(0,r.yg)("inlineCode",{parentName:"h3"},"Handler")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler.succeed")," constructor creates a ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," that always returns a successful response:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\n\nval app: Handler[Any, Nothing, Any, Response] =\n  Handler.succeed(Response.text("Hello, world!"))\n')),(0,r.yg)("p",null,"We have the same constructor for failures called ",(0,r.yg)("inlineCode",{parentName:"p"},"Http.fail"),". It creates a ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," application that always returns a failed response:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\n\nval app: Handler[Any, Response, Any, Nothing] =\n  handler(ZIO.fail(Response.internalServerError("Something went wrong")))\n')),(0,r.yg)("p",null,"We can also create a ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," form a function. The ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler.fromFunction")," constructor takes a total function of type ",(0,r.yg)("inlineCode",{parentName:"p"},"A => B")," and then creates a ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," that accepts an ",(0,r.yg)("inlineCode",{parentName:"p"},"A")," and returns a ",(0,r.yg)("inlineCode",{parentName:"p"},"B"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http._\n\nval app: Handler[Any, Nothing, Int, Double] = Handler.fromFunction[Int](_ / 2.0)\n")),(0,r.yg)("p",null,"Handlers can be effectual. We have a couple of constructors that can be used to create a ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," that are effectual:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Http.fromZIO")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Http.fromStream")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Http.fromFunctionZIO")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Http.fromFile"))),(0,r.yg)("p",null,"There are lots of other constructors, to learn more about them, please refer to the ",(0,r.yg)("a",{parentName:"p",href:"https://zio.dev/zio-http/reference/handler"},(0,r.yg)("inlineCode",{parentName:"a"},"Handler"))," page in the ZIO HTTP documentation."),(0,r.yg)("h3",{id:"combining-handlers"},"Combining Handlers"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," data type is composable like ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO"),". We can create new complex ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," by combining existing simple ones by using ",(0,r.yg)("inlineCode",{parentName:"p"},"flatMap"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"zip"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"andThen"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"orElse"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"++")," methods:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http._\n\nval a           : Handler[Any, Nothing, Int, Double]    = ???\nval b           : Handler[Any, Nothing, Double, String] = ???\ndef c(i: Double): Handler[Any, Nothing, Long, String]   = ???\n\nval d = a >>= c // a flatMap c (combine two handlers sequentially)\nval f = a >>> b // a andThen b (pipe output of the a handler to input of the b handler)\nval h = a <> b  // a orElse b  (run a, if it fails, run b)\n")),(0,r.yg)("h2",{id:"built-in-request-and-response-data-types"},"Built-in ",(0,r.yg)("inlineCode",{parentName:"h2"},"Request")," and ",(0,r.yg)("inlineCode",{parentName:"h2"},"Response")," Data Types"),(0,r.yg)("p",null,"Until now, we have learned how to create a ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler")," with some simple request and response types, e.g. ",(0,r.yg)("inlineCode",{parentName:"p"},"String")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"Int")," in a ",(0,r.yg)("inlineCode",{parentName:"p"},"Handler[Any, Nothing, String, Int]"),". But, in real life, when we want to deal with HTTP requests and responses, we need to have a more complex type for the request and response."),(0,r.yg)("p",null,"ZIO HTTP provides a type ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," for HTTP requests and a type ",(0,r.yg)("inlineCode",{parentName:"p"},"Response")," for HTTP responses. It has a built-in decoder for ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," and an encoder for ",(0,r.yg)("inlineCode",{parentName:"p"},"Response"),". So we don't need to worry about the details of how requests and responses are decoded and encoded."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Response")," type has a default ",(0,r.yg)("inlineCode",{parentName:"p"},"apply")," constructor in its companion object that takes a status, headers, and, HTTP data to create a ",(0,r.yg)("inlineCode",{parentName:"p"},"Response"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"object Response {\n  def apply[R, E](\n    status: Status = Status.Ok,\n    headers: Headers = Headers.empty,\n    data: HttpData = HttpData.Empty\n  ): Response = ???\n}\n")),(0,r.yg)("p",null,"Other than the default constructor, we have several helper methods to create a ",(0,r.yg)("inlineCode",{parentName:"p"},"Response"),". Here are some of them:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"Response.ok")),": Creates a successful response with 200 status code."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},'Response.text("Hello World")')),": Creates a successful response with 200 status code and a body of ",(0,r.yg)("inlineCode",{parentName:"li"},"Hello World"),"."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},"Response.status(Status.BadRequest)")),": Creates a response with a status code of 400."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},'Response.html("<h1>Hello World</h1>")')),": Creates a successful response with 200 status code and an HTML body of ",(0,r.yg)("inlineCode",{parentName:"li"},"<h1>Hello World</h1>"),"."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"strong"},'Response.redirect("/")')),": Creates a successful response that redirects to the root path.")),(0,r.yg)("p",null,"On the other hand, we do not need to create a ",(0,r.yg)("inlineCode",{parentName:"p"},"Request")," instead, we need to pattern-match incoming requests to decompose them and determine the appropriate action to take."),(0,r.yg)("p",null,"Each incoming request can be extracted into two parts using pattern matching:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"HTTP Method (GET, POST, PUT, etc.)"),(0,r.yg)("li",{parentName:"ul"},"Path (e.g. /, /greeting, /download)")),(0,r.yg)("p",null,"Let's see an example of how to pattern match on incoming requests:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\n\nval httpApp: Route[Any, Nothing] =\n  Method.GET / "greet" / string("name") ->\n    handler { (name: String, _: Request) =>\n      Response.text(s"Hello $name!")\n    }\n')),(0,r.yg)("p",null,"Using this DSL we only access the method and path of the incoming request. If we need to access the query string, the body, and more, we need to use the following DSL:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\n\nval httpApp: Route[Any, Response] =\n  Method.GET / "greet" ->\n    handler { (req: Request) =>\n      if (req.url.queryParams.nonEmpty)\n        ZIO.succeed(Response.text(s"Hello ${req.url.queryParams("name").mkString(" and ")}!"))\n      else\n        ZIO.fail(Response.badRequest("Missing query parameter \'name\'"))\n    }\n')),(0,r.yg)("p",null,"Until now, we have learned how to create ",(0,r.yg)("inlineCode",{parentName:"p"},"Route")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"Routes")," applications that handle HTTP requests. In the next section, we will learn how to create HTTP servers that can serve HTTP routes."),(0,r.yg)("h2",{id:"creating-http-server"},"Creating HTTP Server"),(0,r.yg)("p",null,"To start an HTTP server, the ZIO HTTP requires a ",(0,r.yg)("inlineCode",{parentName:"p"},"Routes")," of type ",(0,r.yg)("inlineCode",{parentName:"p"},"Routes[Env, Response]")," and returns an effect that requires a ",(0,r.yg)("inlineCode",{parentName:"p"},"Server")," from the environment and never produces a value and never fails:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"object Server {\n  def server[R](\n    http: Routes[Env, Response]\n  ): ZIO[R with Server, Nothing, Nothing] = ???\n}\n")),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},'If you encounter a "port already in use" error, you can use ',(0,r.yg)("inlineCode",{parentName:"p"},"sbt-revolver")," to manage server restarts more effectively. The ",(0,r.yg)("inlineCode",{parentName:"p"},"reStart")," command will start your server and ",(0,r.yg)("inlineCode",{parentName:"p"},"reStop")," will properly stop it, releasing the port."),(0,r.yg)("p",{parentName:"admonition"},"To enable this feature, we have included ",(0,r.yg)("inlineCode",{parentName:"p"},"sbt-revolver")," in the project. For more details on this, refer to the ",(0,r.yg)("a",{parentName:"p",href:"https://zio.dev/zio-http/installation#hot-reload-changes-watch-mode"},"ZIO HTTP documentation on hot-reloading"),".")),(0,r.yg)("h2",{id:"greeting-app"},"Greeting App"),(0,r.yg)("p",null,"First, we need to define a request handler that will handle ",(0,r.yg)("inlineCode",{parentName:"p"},"GET")," requests to the ",(0,r.yg)("inlineCode",{parentName:"p"},"/greet")," path:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\n\nobject GreetingRoutes {\n  def apply(): Routes[Any, Response] =\n    Routes(\n      // GET /greet?name=:name\n      Method.GET / "greet" -> handler { (req: Request) =>\n        if (req.url.queryParams.nonEmpty)\n          ZIO.succeed(\n            Response.text(\n              s"Hello ${req.url.queryParams("name").map(_.mkString(" and "))}!"\n            )\n          )\n        else\n          ZIO.fail(Response.badRequest("The name query parameter is missing!"))\n      },\n\n      // GET /greet\n      Method.GET / "greet" -> handler(Response.text(s"Hello World!")),\n\n      // GET /greet/:name\n      Method.GET / "greet" / string("name") -> handler {\n        (name: String, _: Request) =>\n          Response.text(s"Hello $name!")\n      }\n    )\n\n}\n')),(0,r.yg)("p",null,"In the above example, we have defined three routes:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The first case matches a request with a path of ",(0,r.yg)("inlineCode",{parentName:"li"},"/greet")," and a query parameter ",(0,r.yg)("inlineCode",{parentName:"li"},"name"),"."),(0,r.yg)("li",{parentName:"ul"},"The second case matches a request with a path of ",(0,r.yg)("inlineCode",{parentName:"li"},"/greet")," with no query parameters."),(0,r.yg)("li",{parentName:"ul"},"The third case matches a request with a path of ",(0,r.yg)("inlineCode",{parentName:"li"},"/greet/:name")," and extracts the ",(0,r.yg)("inlineCode",{parentName:"li"},"name")," from the path.")),(0,r.yg)("p",null,"Next, we need to create a server for ",(0,r.yg)("inlineCode",{parentName:"p"},"GreetingRoutes"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.http._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    Server.serve(GreetingRoutes()).provide(Server.default)\n}\n")),(0,r.yg)("p",null,"Now, we have three endpoints in our server. We can test the server according to the steps mentioned in the corresponding ",(0,r.yg)("a",{parentName:"p",href:"/guides/quickstarts/restful-webservice"},"quickstart"),"."),(0,r.yg)("p",null,"Note that if we have written other routes along with ",(0,r.yg)("inlineCode",{parentName:"p"},"GreetingRoutes"),", such as ",(0,r.yg)("inlineCode",{parentName:"p"},"DownloadRoutes"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"CounterRoutes"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"UserRoutes"),", we can combine them together and start a server for that routes:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.http._\n\nServer.serve(\n  GreetingRoutes() ++ DownloadRoutes() ++ CounterRoutes() ++ UserRoutes()\n).provide(Server.default)\n")),(0,r.yg)("h2",{id:"conclusion"},"Conclusion"),(0,r.yg)("p",null,"In this tutorial, we have learned the basic building blocks of writing HTTP servers. We learned how to write routes and handlers. And finally, we saw how to create an HTTP server that can handle HTTP applications."),(0,r.yg)("p",null,"All the source code associated with this article is available on the ",(0,r.yg)("a",{parentName:"p",href:"http://github.com/zio/zio-quickstarts"},"ZIO Quickstart")," project."))}g.isMDXComponent=!0}}]);