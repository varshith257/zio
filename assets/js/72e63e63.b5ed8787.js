"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[21652],{15680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>h});var o=t(96540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=o.createContext({}),l=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=l(e.components);return o.createElement(s.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),u=l(t),m=i,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||a;return t?o.createElement(h,r(r({ref:n},d),{},{components:t})):o.createElement(h,r({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=m;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p[u]="string"==typeof e?e:i,r[1]=p;for(var l=2;l<a;l++)r[l]=t[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},20611:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>p,toc:()=>l});var o=t(58168),i=(t(96540),t(15680));const a={id:"endpoint",title:"Endpoint"},r=void 0,p={unversionedId:"zio-http/reference/endpoint",id:"zio-http/reference/endpoint",title:"Endpoint",description:"The Endpoint API in ZIO HTTP, is an alternative way to describe the endpoints but in a declarative way. It is a high-level API that allows us to describe the endpoints and their inputs, outputs, and how they should look. So we can think of it as a DSL for just describing the endpoints, and then we can implement them separately.",source:"@site/docs/zio-http/reference/endpoint.md",sourceDirName:"zio-http/reference",slug:"/zio-http/reference/endpoint",permalink:"/zio-http/reference/endpoint",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/endpoint.md",tags:[],version:"current",frontMatter:{id:"endpoint",title:"Endpoint"},sidebar:"ecosystem-sidebar",previous:{title:"Template",permalink:"/zio-http/reference/body/template"},next:{title:"HttpCodec",permalink:"/zio-http/reference/http-codec"}},s={},l=[{value:"Overview",id:"overview",level:2},{value:"Describing Endpoints",id:"describing-endpoints",level:2},{value:"Describing Input Properties",id:"describing-input-properties",level:2},{value:"Method and Path Parameters",id:"method-and-path-parameters",level:3},{value:"Query Parameters",id:"query-parameters",level:3},{value:"Headers",id:"headers",level:3},{value:"Request Body",id:"request-body",level:3},{value:"Describing Output Properties of Success Responses",id:"describing-output-properties-of-success-responses",level:2},{value:"Describing Failures",id:"describing-failures",level:2},{value:"Multiple Failure Outputs Using <code>Endpoint#outError</code>",id:"multiple-failure-outputs-using-endpointouterror",level:3},{value:"Multiple Failure Outputs <code>Endpoint#outErrors</code>",id:"multiple-failure-outputs-endpointouterrors",level:3},{value:"Transforming Endpoint Input/Output and Error Types",id:"transforming-endpoint-inputoutput-and-error-types",level:2},{value:"OpenAPI Documentation",id:"openapi-documentation",level:2},{value:"Generating Endpoint from OpenAPI Spec",id:"generating-endpoint-from-openapi-spec",level:2},{value:"Generating ZIO CLI App from Endpoint API",id:"generating-zio-cli-app-from-endpoint-api",level:2}],d={toc:l},u="wrapper";function c(e){let{components:n,...t}=e;return(0,i.yg)(u,(0,o.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API in ZIO HTTP, is an alternative way to describe the endpoints but in a declarative way. It is a high-level API that allows us to describe the endpoints and their inputs, outputs, and how they should look. So we can think of it as a DSL for just describing the endpoints, and then we can implement them separately."),(0,i.yg)("p",null,"Using ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API enables us to generate OpenAPI documentation, and also to generate clients for the endpoints."),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,"Before delving into the detailed description of the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API, let's begin with a simple example to demonstrate how we can define an endpoint using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.codec._\nimport zio.http.endpoint.Endpoint\nimport zio.schema.DeriveSchema\n\ncase class Book(title: String, authors: List[String])\nobject Book {\n  implicit val schema = DeriveSchema.gen[Book]\n}\n\nval endpoint =\n  Endpoint(RoutePattern.GET / "books")\n    .query(HttpCodec.query[String]("q") examples (("example1", "scala"), ("example2", "zio")))\n    .out[List[Book]]\n')),(0,i.yg)("p",null,"In the above example, we defined an endpoint on the path ",(0,i.yg)("inlineCode",{parentName:"p"},"/books")," that accepts a query parameter ",(0,i.yg)("inlineCode",{parentName:"p"},"q")," of type ",(0,i.yg)("inlineCode",{parentName:"p"},"String")," and returns a list of ",(0,i.yg)("inlineCode",{parentName:"p"},"Book"),"."),(0,i.yg)("p",null,"After defining the endpoint, we are ready to implement it. We can implement it using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#implement")," method, which takes a proper handler function that will be called when the endpoint is invoked and returns a ",(0,i.yg)("inlineCode",{parentName:"p"},"Route"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"val booksRoute = endpoint.implement(query => BookRepo.find(query))\n")),(0,i.yg)("p",null,"We can also generate OpenAPI documentation for our endpoint using the ",(0,i.yg)("inlineCode",{parentName:"p"},"OpenAPIGen.fromEndpoints")," constructor:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val openAPI       = OpenAPIGen.fromEndpoints(title = "Library API", version = "1.0", endpoint)\nval swaggerRoutes = SwaggerUI.routes("docs" / "openapi", openAPI)\n')),(0,i.yg)("p",null,"And finally we are ready to serve all the routes. Let's see the complete example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/BooksEndpointExample.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/BooksEndpointExample.scala"'},'package example.endpoint\n\nimport zio._\n\nimport zio.schema.annotation.description\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\nimport zio.http.codec.PathCodec._\nimport zio.http.codec._\nimport zio.http.endpoint._\nimport zio.http.endpoint.openapi._\n\nobject BooksEndpointExample extends ZIOAppDefault {\n  case class Book(\n    @description("Title of the book")\n    title: String,\n    @description("List of the authors of the book")\n    authors: List[String],\n  )\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  object BookRepo {\n    val book1 = Book("Programming in Scala", List("Martin Odersky", "Lex Spoon", "Bill Venners", "Frank Sommers"))\n    val book2 = Book("Zionomicon", List("John A. De Goes", "Adam Fraser"))\n    val book3 = Book("Effect-Oriented Programming", List("Bill Frasure", "Bruce Eckel", "James Ward"))\n    def find(q: String): List[Book] = {\n      if (q.toLowerCase == "scala") List(book1, book2, book3)\n      else if (q.toLowerCase == "zio") List(book2, book3)\n      else List.empty\n    }\n  }\n\n  val endpoint =\n    Endpoint((RoutePattern.GET / "books") ?? Doc.p("Route for querying books"))\n      .query(\n        HttpCodec.query[String]("q").examples(("example1", "scala"), ("example2", "zio")) ?? Doc.p(\n          "Query parameter for searching books",\n        ),\n      )\n      .out[List[Book]](Doc.p("List of books matching the query")) ?? Doc.p(\n      "Endpoint to query books based on a search query",\n    )\n\n  val booksRoute    = endpoint.implementHandler(handler((query: String) => BookRepo.find(query)))\n  val openAPI       = OpenAPIGen.fromEndpoints(title = "Library API", version = "1.0", endpoint)\n  val swaggerRoutes = SwaggerUI.routes("docs" / "openapi", openAPI)\n  val routes        = Routes(booksRoute) ++ swaggerRoutes\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n')),(0,i.yg)("p",null,"By running the above example, other than the main ",(0,i.yg)("inlineCode",{parentName:"p"},"/books")," route, we can also access the OpenAPI documentation using the SwaggerUI at the ",(0,i.yg)("inlineCode",{parentName:"p"},"/docs/openapi")," route."),(0,i.yg)("p",null,"This was an overview of the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API in ZIO HTTP. Next, we will dive deeper into the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API and see how we can describe the endpoints in more detail."),(0,i.yg)("h2",{id:"describing-endpoints"},"Describing Endpoints"),(0,i.yg)("p",null,"Each endpoint is described by a set of properties, such as the path, query parameters, headers, and response type. The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API provides a set of methods to describe these properties. We can think of an endpoint as a function that takes some input and returns some output:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Input Properties"),"\u2014 They can be the HTTP method, path parameters, query parameters, request headers, and the request body."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Output Properties"),"\xad\u2014 They can be success or failure! Both success and failure can have a response body, media type, and status code.")),(0,i.yg)("p",null,"Also, we can provide metadata for each property, such as documentation, examples, etc."),(0,i.yg)("h2",{id:"describing-input-properties"},"Describing Input Properties"),(0,i.yg)("h3",{id:"method-and-path-parameters"},"Method and Path Parameters"),(0,i.yg)("p",null,"We start describing an endpoint by specifying the HTTP method and the path. The default constructor of the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," class takes a ",(0,i.yg)("inlineCode",{parentName:"p"},"RoutePattern")," which is a combination of the HTTP method and the path:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.endpoint._\nimport zio.http.endpoint.AuthType._\nimport zio.http.codec.PathCodec\n\nval endpoint1: Endpoint[Unit, Unit, ZNothing, ZNothing, None] =\n  Endpoint(RoutePattern.GET / "users")\n\nval endpoint2: Endpoint[String, String, ZNothing, ZNothing, None] =\n  Endpoint(RoutePattern.GET / "users" / PathCodec.string("user_name"))\n\nval endpoint3: Endpoint[(String, Int), (String, Int), ZNothing, ZNothing, None] =\n  Endpoint(RoutePattern.GET / "users" / PathCodec.string("user_name") / "posts" / PathCodec.int("post_id"))\n')),(0,i.yg)("p",null,"In the above examples, we defined three endpoints. The first one is a simple endpoint that matches the GET method on the ",(0,i.yg)("inlineCode",{parentName:"p"},"/users")," path. The second one matches the GET method on the ",(0,i.yg)("inlineCode",{parentName:"p"},"/users/:user_name")," path, where ",(0,i.yg)("inlineCode",{parentName:"p"},":user_name")," is a path parameter of type ",(0,i.yg)("inlineCode",{parentName:"p"},"String"),". The third one matches the GET method on the ",(0,i.yg)("inlineCode",{parentName:"p"},"/users/:user_name/posts/:post_id")," path, where ",(0,i.yg)("inlineCode",{parentName:"p"},":user_name")," and ",(0,i.yg)("inlineCode",{parentName:"p"},":post_id")," are path parameters of type ",(0,i.yg)("inlineCode",{parentName:"p"},"String")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Int"),", respectively."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," is a type-safe way to describe the endpoints. For example, if we try to implement the ",(0,i.yg)("inlineCode",{parentName:"p"},"endpoint3")," with a handler that takes a different input type other than ",(0,i.yg)("inlineCode",{parentName:"p"},"(String, Int)"),", the compiler will give us an error."),(0,i.yg)("h3",{id:"query-parameters"},"Query Parameters"),(0,i.yg)("p",null,"Query parameters can be described using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#query")," method which takes a ",(0,i.yg)("inlineCode",{parentName:"p"},"QueryCodec[A]"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val endpoint: Endpoint[Unit, String, ZNothing, ZNothing, AuthType.None] =\n  Endpoint(RoutePattern.GET / "books")\n    .query(HttpCodec.query[String]("q"))\n')),(0,i.yg)("p",null,"QueryCodecs are composable, so we can combine multiple query parameters:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val endpoint: Endpoint[Unit, (String, Int), ZNothing, ZNothing, AuthType.None] =\n  Endpoint(RoutePattern.GET / "books")\n    .query(HttpCodec.query[String]("q") ++ HttpCodec.query[Int]("limit"))\n')),(0,i.yg)("p",null,"Or we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"query")," method multiple times:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val endpoint: Endpoint[Unit, (String, Int), ZNothing, ZNothing, AuthType.None] =\n  Endpoint(RoutePattern.GET / "books")\n    .query(HttpCodec.query[String]("q"))\n    .query(HttpCodec.query[Int]("limit"))\n')),(0,i.yg)("p",null,"Please note that as we add more properties to the endpoint, the input and output types of the endpoint change accordingly. For example, in the following example, we have an endpoint with a path parameter of type ",(0,i.yg)("inlineCode",{parentName:"p"},"String")," and two query parameters of type ",(0,i.yg)("inlineCode",{parentName:"p"},"String")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Int"),". So the input type of the endpoint is ",(0,i.yg)("inlineCode",{parentName:"p"},"(String, String, Int)"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val endpoint: Endpoint[String, (String, String, Int), ZNothing, ZNothing, AuthType.None] =\n  Endpoint(RoutePattern.GET / "books" / PathCodec.string("genre"))\n    .query(HttpCodec.query[String]("q"))\n    .query(HttpCodec.query[Int]("limit"))\n')),(0,i.yg)("p",null,'When we implement the endpoint, the handler function should take the input type of a tuple that the first element is the "genre" path parameter, and the second and third elements are the query parameters "q" and "limit" respectively.'),(0,i.yg)("h3",{id:"headers"},"Headers"),(0,i.yg)("p",null,"Headers can be described using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#header")," method which takes a ",(0,i.yg)("inlineCode",{parentName:"p"},"HeaderCodec[A]")," and specifies that the given header is required, for example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val endpoint: Endpoint[String, (String, Header.Authorization), ZNothing, ZNothing, AuthType.None] =\n  Endpoint(RoutePattern.GET / "books" / PathCodec.string("genre"))\n    .header(HeaderCodec.authorization)\n')),(0,i.yg)("h3",{id:"request-body"},"Request Body"),(0,i.yg)("p",null,"The request body can be described using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#in")," method:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.schema._\n\ncase class Book(title: String, author: String)\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen[Book]\n}\n\nval endpoint: Endpoint[Unit, Book, ZNothing, ZNothing, AuthType.None] =\n  Endpoint(RoutePattern.POST / "books" )\n    .in[Book]\n')),(0,i.yg)("p",null,"The above example describes an endpoint that accepts a ",(0,i.yg)("inlineCode",{parentName:"p"},"Book")," object as the request body."),(0,i.yg)("p",null,"By default, the request body is not named and its media type is determined by the ",(0,i.yg)("inlineCode",{parentName:"p"},"Content-Type")," header. But for multipart form data, we can have multiple request bodies, called parts:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val endpoint =\n  Endpoint(RoutePattern.POST / "submit-form")\n    .header(HeaderCodec.contentType.expect(Header.ContentType(MediaType.multipart.`form-data`)))\n    .in[String]("title")\n    .in[String]("author")\n')),(0,i.yg)("p",null,"In the above example, we have defined an endpoint that describes a multipart form data request body with two parts: ",(0,i.yg)("inlineCode",{parentName:"p"},"title")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"author"),". Let's see what the request body might look like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-http",metastring:"request",request:!0},'POST /submit-form HTTP/1.1\nContent-Type: multipart/form-data; boundary=boundary1234567890\n\n--boundary1234567890\nContent-Disposition: form-data; name="title"\n\nThe Title of the Book\n--boundary1234567890\nContent-Disposition: form-data; name="author"\n\nJohn Doe\n--boundary1234567890--\n')),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#in")," method has multiple overloads that can be used to describe other properties of the request body, such as the media type and documentation."),(0,i.yg)("h2",{id:"describing-output-properties-of-success-responses"},"Describing Output Properties of Success Responses"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#out")," method is used to describe the output properties of the success response:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\nimport zio.schema._\n\ncase class Book(title: String, author: String)\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen[Book]\n}\n\nval endpoint: Endpoint[Unit, String, ZNothing, List[Book], AuthType.None] =\n  Endpoint(RoutePattern.GET / "books")\n    .query(HttpCodec.query[String]("q"))\n    .out[List[Book]]\n')),(0,i.yg)("p",null,"In the above example, we defined an endpoint that describes a query parameter ",(0,i.yg)("inlineCode",{parentName:"p"},"q")," as input and returns a list of ",(0,i.yg)("inlineCode",{parentName:"p"},"Book")," as output. The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#out")," method has multiple overloads that can be used to describe other properties of the output, such as the status code, media type, and documentation."),(0,i.yg)("p",null,"We can also add custom headers to the output using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#outHeader")," method:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.http._\nimport zio.schema._\n\ncase class Book(title: String, author: String)\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen[Book]\n}\n\nval endpoint: Endpoint[Unit, String, ZNothing, (List[Book], Header.Date), AuthType.None] =\n    Endpoint(RoutePattern.GET / "books")\n      .query(HttpCodec.query[String]("q"))\n      .out[List[Book]]\n      .outHeader(HttpCodec.date)\n')),(0,i.yg)("p",null,"Sometimes based on the condition, we might want to return different types of responses. We can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#out")," method multiple times to describe different output types:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http.{RoutePattern, _}\nimport zio.http.endpoint.Endpoint\nimport zio.schema.DeriveSchema.gen\nimport zio.schema._\n\ncase class Book(title: String, author: String)\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen\n}\n\ncase class Article(title: String, author: String)\n\nobject Article {\n  implicit val schema: Schema[Article] = DeriveSchema.gen\n}\n\ncase class Course(title: String, price: Double)\nobject Course {\n  implicit val schema = DeriveSchema.gen[Course]\n}\n\ncase class Quiz(question: String, level: Int)\nobject Quiz {\n  implicit val schema = DeriveSchema.gen[Quiz]\n}\n\nobject EndpointWithMultipleOutputTypes extends ZIOAppDefault {\n  val endpoint: Endpoint[Unit, Unit, ZNothing, Either[Quiz, Course], AuthType.None] =\n    Endpoint(RoutePattern.GET / "resources")\n      .out[Course]\n      .out[Quiz]\n\n  def run = Server.serve(\n    endpoint.implement(_ =>\n      ZIO.randomWith(_.nextBoolean)\n        .map(r =>\n          if (r) Right(Course("Introduction to Programming", 49.99))\n          else Left(Quiz("What is the boiling point of water in Celsius?", 2)),\n        )\n    )\n    .toRoutes).provide(Server.default)\n}\n')),(0,i.yg)("p",null,"In the above example, we defined an endpoint that describes a path parameter ",(0,i.yg)("inlineCode",{parentName:"p"},"id")," as input and returns either a ",(0,i.yg)("inlineCode",{parentName:"p"},"Book")," or an ",(0,i.yg)("inlineCode",{parentName:"p"},"Article")," as output."),(0,i.yg)("p",null,"With multiple outputs, we can define if all of them or just some should add an output header, by the order of calling ",(0,i.yg)("inlineCode",{parentName:"p"},"out")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"outHeader")," methods:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.endpoint._\nimport zio.schema._\n\ncase class Book(title: String, author: String)\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen\n}\n\ncase class Article(title: String, author: String)\n\nobject Article {\n  implicit val schema: Schema[Article] = DeriveSchema.gen\n}\n// header will be added to the first output\nval endpoint: Endpoint[Unit, Unit, ZNothing, Either[Article, (Book, Header.Date)], AuthType.None] =\n  Endpoint(RoutePattern.GET / "resources")\n    .out[Book]\n    .outHeader(HttpCodec.date)\n    .out[Article]\n\n// header will be added to all outputs\nval endpoint2: Endpoint[Unit, Unit, ZNothing, (Either[Article, Book], Header.Date), AuthType.None] =\n  Endpoint(RoutePattern.GET / "resources")\n    .out[Book]\n    .out[Article]\n    .outHeader(HttpCodec.date)\n')),(0,i.yg)("p",null,"A call to ",(0,i.yg)("inlineCode",{parentName:"p"},"outHeder")," will require to provide the header together with all outputs defined before it."),(0,i.yg)("p",null,"Sometimes we might want more control over the output properties, in such cases, we can provide a custom ",(0,i.yg)("inlineCode",{parentName:"p"},"HttpCodec")," that describes the output properties using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#outCodec")," method.\nThis can be very useful when we only want to add headers to a subset of outputs for example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.endpoint._\nimport zio.schema._\n\ncase class Book(title: String, author: String)\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen\n}\n\ncase class Article(title: String, author: String)\n\nobject Article {\n  implicit val schema: Schema[Article] = DeriveSchema.gen\n}\nval endpoint: Endpoint[Unit, Unit, ZNothing, Either[(Article, Header.Date), Book], AuthType.None] =\n  Endpoint(RoutePattern.GET / "resources")\n    .out[Book]\n    .outCodec(HttpCodec.content[Article] ++ HttpCodec.date)\n')),(0,i.yg)("p",null,"Or when we want to reuse the same codec for multiple endpoints:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.endpoint._\nimport zio.schema._\n\ncase class Book(title: String, author: String)\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen\n}\n\ncase class Article(title: String, author: String)\n\nobject Article {\n  implicit val schema: Schema[Article] = DeriveSchema.gen\n}\nval bookCodec = HttpCodec.content[Book] ++ HttpCodec.date\nval articleCodec = HttpCodec.content[Article] ++ HttpCodec.date\n\nval endpoint1: Endpoint[Unit, Unit, ZNothing, (Book, Header.Date), AuthType.None] =\n  Endpoint(RoutePattern.GET / "books")\n    .outCodec(bookCodec)\n\nval endpoint2: Endpoint[Unit, Unit, ZNothing, (Article, Header.Date), AuthType.None] =\n    Endpoint(RoutePattern.GET / "articles")\n        .outCodec(articleCodec)\n\nval endpoint3: Endpoint[Unit, Unit, ZNothing, Either[(Article, Header.Date), (Book, Header.Date)], AuthType.None] =\n    Endpoint(RoutePattern.GET / "resources")\n        .outCodec(articleCodec | bookCodec)\n')),(0,i.yg)("h2",{id:"describing-failures"},"Describing Failures"),(0,i.yg)("p",null,"For failure outputs, we can describe the output properties using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#outError*")," methods. Let's see an example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/style/DeclarativeProgrammingExample.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/style/DeclarativeProgrammingExample.scala"'},'package example.endpoint.style\n\nimport zio._\n\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\nimport zio.http.codec._\nimport zio.http.endpoint.{AuthType, Endpoint}\n\nobject DeclarativeProgrammingExample extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n  case class NotFoundError(message: String)\n\n  object NotFoundError {\n    implicit val schema: Schema[NotFoundError] = DeriveSchema.gen\n  }\n\n  object BookRepo {\n    def find(id: String): ZIO[Any, NotFoundError, Book] = {\n      if (id == "1")\n        ZIO.succeed(Book("Zionomicon", List("John A. De Goes", "Adam Fraser")))\n      else\n        ZIO.fail(NotFoundError("The requested book was not found!"))\n    }\n  }\n\n  val endpoint: Endpoint[Unit, String, NotFoundError, Book, AuthType.None] =\n    Endpoint(RoutePattern.GET / "books")\n      .query(HttpCodec.query[String]("id"))\n      .out[Book]\n      .outError[NotFoundError](Status.NotFound)\n\n  val getBookHandler: Handler[Any, NotFoundError, String, Book] =\n    handler(BookRepo.find(_))\n\n  val routes = endpoint.implementHandler(getBookHandler).toRoutes @@ Middleware.debug\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n')),(0,i.yg)("p",null,"In the above example, we defined an endpoint that describes a query parameter ",(0,i.yg)("inlineCode",{parentName:"p"},"id")," as input and returns a ",(0,i.yg)("inlineCode",{parentName:"p"},"Book")," as output. If the book is not found, the endpoint returns a ",(0,i.yg)("inlineCode",{parentName:"p"},"NotFound")," status code with a custom error message."),(0,i.yg)("h3",{id:"multiple-failure-outputs-using-endpointouterror"},"Multiple Failure Outputs Using ",(0,i.yg)("inlineCode",{parentName:"h3"},"Endpoint#outError")),(0,i.yg)("p",null,"If we have multiple failure outputs, we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#outError")," method multiple times to describe different error types. By specifying more error types, the type of the endpoint will be the union of all the error types (e.g., ",(0,i.yg)("inlineCode",{parentName:"p"},"Either[Error1, Error2]"),"):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.schema._\nimport zio.schema.DeriveSchema\n\ncase class Book(title: String, authors: List[String])\ncase class BookNotFound(message: String, bookId: Int)\ncase class AuthenticationError(message: String, userId: Int)\n\nimplicit val bookSchema     = DeriveSchema.gen[Book]\nimplicit val notFoundSchema = DeriveSchema.gen[BookNotFound]\nimplicit val authSchema     = DeriveSchema.gen[AuthenticationError]\n\nval endpoint: Endpoint[Int, (Int, Header.Authorization), Either[AuthenticationError, BookNotFound], Book, AuthType.None] =\n  Endpoint(RoutePattern.GET / "books" / PathCodec.int("id"))\n    .header(HeaderCodec.authorization)\n    .out[Book]\n    .outError[BookNotFound](Status.NotFound)\n    .outError[AuthenticationError](Status.Unauthorized)\n')),(0,i.yg)("details",null,(0,i.yg)("summary",null,(0,i.yg)("b",null,"Full Implementation Showcase")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/EndpointWithMultipleErrorsUsingEither.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/EndpointWithMultipleErrorsUsingEither.scala"'},'package example.endpoint\n\nimport zio._\n\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\nimport zio.http.codec._\nimport zio.http.endpoint.{AuthType, Endpoint}\n\nobject EndpointWithMultipleErrorsUsingEither extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  case class BookNotFound(message: String, bookId: Int)\n\n  object BookNotFound {\n    implicit val schema: Schema[BookNotFound] = DeriveSchema.gen\n  }\n\n  case class AuthenticationError(message: String, userId: Int)\n\n  object AuthenticationError {\n    implicit val schema: Schema[AuthenticationError] = DeriveSchema.gen\n  }\n\n  object BookRepo {\n    def find(id: Int): ZIO[Any, BookNotFound, Book] = {\n      if (id == 1)\n        ZIO.succeed(Book("Zionomicon", List("John A. De Goes", "Adam Fraser")))\n      else\n        ZIO.fail(BookNotFound("The requested book was not found.", id))\n    }\n  }\n\n  val endpoint\n    : Endpoint[Int, (Int, Header.Authorization), Either[AuthenticationError, BookNotFound], Book, AuthType.None] =\n    Endpoint(RoutePattern.GET / "books" / PathCodec.int("id"))\n      .header(HeaderCodec.authorization)\n      .out[Book]\n      .outError[BookNotFound](Status.NotFound)\n      .outError[AuthenticationError](Status.Unauthorized)\n\n  def isUserAuthorized(authHeader: Header.Authorization) = false\n\n  val getBookHandler\n    : Handler[Any, Either[AuthenticationError, BookNotFound], (RuntimeFlags, Header.Authorization), Book] =\n    handler { (id: Int, authHeader: Header.Authorization) =>\n      if (isUserAuthorized(authHeader))\n        BookRepo.find(id).mapError(Right(_))\n      else\n        ZIO.fail(Left(AuthenticationError("User is not authenticated", 123)))\n    }\n\n  val routes = endpoint.implementHandler(getBookHandler).toRoutes @@ Middleware.debug\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n'))),(0,i.yg)("h3",{id:"multiple-failure-outputs-endpointouterrors"},"Multiple Failure Outputs ",(0,i.yg)("inlineCode",{parentName:"h3"},"Endpoint#outErrors")),(0,i.yg)("p",null,"Alternatively, the idiomatic way to describe multiple failure outputs is to unify all the error types into a single error type using a sealed trait or an enum, and then describe the output properties using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#outErrors")," method:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.schema.DeriveSchema\n\ncase class Book(title: String, authors: List[String])\nimplicit val bookSchema = DeriveSchema.gen[Book]\n\nabstract class AppError(message: String)\ncase class BookNotFound(message: String, bookId: Int)        extends AppError(message)\ncase class AuthenticationError(message: String, userId: Int) extends AppError(message)\n\nimplicit val notFoundSchema = DeriveSchema.gen[BookNotFound]\nimplicit val authSchema     = DeriveSchema.gen[AuthenticationError]\n\nval endpoint: Endpoint[Int, (Int, Header.Authorization), AppError, Book, AuthType.None] =\n  Endpoint(RoutePattern.GET / "books" / PathCodec.int("id"))\n    .header(HeaderCodec.authorization)\n    .out[Book]\n    .outErrors[AppError](\n      HttpCodec.error[BookNotFound](Status.NotFound),\n      HttpCodec.error[AuthenticationError](Status.Unauthorized),\n    )\n')),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#outErrors")," method takes a list of ",(0,i.yg)("inlineCode",{parentName:"p"},"HttpCodec")," that describes the error types and their corresponding status codes."),(0,i.yg)("details",null,(0,i.yg)("summary",null,(0,i.yg)("b",null,"Full Implementation Showcase")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/EndpointWithMultipleUnifiedErrors.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/EndpointWithMultipleUnifiedErrors.scala"'},'package example.endpoint\n\nimport scala.annotation.nowarn\n\nimport zio._\n\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\nimport zio.http.codec._\nimport zio.http.endpoint.{AuthType, Endpoint}\n\nobject EndpointWithMultipleUnifiedErrors extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  @nowarn("msg=parameter .* never used")\n  abstract class AppError(message: String)\n\n  case class BookNotFound(message: String, bookId: Int) extends AppError(message)\n\n  object BookNotFound {\n    implicit val schema: Schema[BookNotFound] = DeriveSchema.gen\n  }\n\n  case class AuthenticationError(message: String, userId: Int) extends AppError(message)\n\n  object AuthenticationError {\n    implicit val schema: Schema[AuthenticationError] = DeriveSchema.gen\n  }\n\n  object BookRepo {\n    def find(id: Int): ZIO[Any, BookNotFound, Book] = {\n      if (id == 1)\n        ZIO.succeed(Book("Zionomicon", List("John A. De Goes", "Adam Fraser")))\n      else\n        ZIO.fail(BookNotFound("The requested book was not found.", id))\n    }\n  }\n\n  val endpoint: Endpoint[Int, (Int, Header.Authorization), AppError, Book, AuthType.None] =\n    Endpoint(RoutePattern.GET / "books" / PathCodec.int("id"))\n      .header(HeaderCodec.authorization)\n      .out[Book]\n      .outErrors[AppError](\n        HttpCodec.error[BookNotFound](Status.NotFound),\n        HttpCodec.error[AuthenticationError](Status.Unauthorized),\n      )\n\n  def isUserAuthorized(authHeader: Header.Authorization) = false\n\n  val getBookHandler: Handler[Any, AppError, (Int, Header.Authorization), Book] =\n    handler { (id: Int, authHeader: Header.Authorization) =>\n      if (isUserAuthorized(authHeader))\n        BookRepo.find(id)\n      else\n        ZIO.fail(AuthenticationError("User is not authenticated", 123))\n    }\n\n  val routes = endpoint.implementHandler(getBookHandler).toRoutes @@ Middleware.debug\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n'))),(0,i.yg)("h2",{id:"transforming-endpoint-inputoutput-and-error-types"},"Transforming Endpoint Input/Output and Error Types"),(0,i.yg)("p",null,"To transform the input, output, and error types of an endpoint, we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#transformIn"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#transformOut"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#transformError")," methods, respectively. Let's see an example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'case class BookQuery(query: String, genre: String, title: String)\n\nval endpoint: Endpoint[String, (String, String, String), ZNothing, ZNothing, AuthType.None] =\n  Endpoint(RoutePattern.POST / "books" / PathCodec.string("genre"))\n    .query(HttpCodec.query[String]("q"))\n    .query(HttpCodec.query[String]("title"))\n\nval mappedEndpoint: Endpoint[String, BookQuery, ZNothing, ZNothing, AuthType.None] =\n  endpoint.transformIn[BookQuery] { case (genre, q, title) => BookQuery(q, genre, title) } { i =>\n    (i.genre, i.query, i.title)\n  }\n')),(0,i.yg)("p",null,"In the above example, we mapped over the input type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"endpoint")," and transformed it into a single ",(0,i.yg)("inlineCode",{parentName:"p"},"BookQuery")," object. The ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint#transformIn")," method takes two functions, the first one is used to map the input type to the new input type, and the second one is responsible for mapping the new input type back to the original input type."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"transformOut")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"transformError")," methods work similarly to the ",(0,i.yg)("inlineCode",{parentName:"p"},"transformIn")," method."),(0,i.yg)("h2",{id:"openapi-documentation"},"OpenAPI Documentation"),(0,i.yg)("p",null,"Every property of an ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API can be annotated with documentation, may be examples using methods like ",(0,i.yg)("inlineCode",{parentName:"p"},"??")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"example*"),". We can use these metadata to generate OpenAPI documentation:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val endpoint =\n  Endpoint((RoutePattern.GET / "books") ?? Doc.p("Route for querying books"))\n    .query(\n      HttpCodec.query[String]("q").examples(("example1", "scala"), ("example2", "zio")) ?? Doc.p(\n        "Query parameter for searching books",\n      ),\n    )\n    .out[List[Book]](Doc.p("List of books matching the query")) ?? Doc.p(\n    "Endpoint to query books based on a search query",\n  )\n')),(0,i.yg)("p",null,"Also, we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"@description")," annotation from the ",(0,i.yg)("inlineCode",{parentName:"p"},"zio.schema.annotation")," package to annotate data models, which will enrich the OpenAPI documentation:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.schema.annotation.description\n\ncase class Book(\n  @description("Title of the book")\n  title: String,\n  @description("List of the authors of the book")\n  authors: List[String],\n)\n')),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"OpenAPIGen.fromEndpoints")," constructor generates OpenAPI documentation from the endpoints. By having the OpenAPI documentation, we can easily generate Swagger UI routes using the ",(0,i.yg)("inlineCode",{parentName:"p"},"SwaggerUI.routes")," constructor:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'val booksRoute = endpoint.implement(query => BookRepo.find(query))\nval openAPI    = OpenAPIGen.fromEndpoints(title = "Library API", version = "1.0", endpoint)\nval swaggerRoutes = SwaggerUI.routes("docs" / "openapi", openAPI)\nval routes     = Routes(booksRoute) ++ swaggerRoutes\n')),(0,i.yg)("details",null,(0,i.yg)("summary",null,(0,i.yg)("b",null,"Full Implementation Showcase")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/BooksEndpointExample.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/BooksEndpointExample.scala"'},'package example.endpoint\n\nimport zio._\n\nimport zio.schema.annotation.description\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\nimport zio.http.codec.PathCodec._\nimport zio.http.codec._\nimport zio.http.endpoint._\nimport zio.http.endpoint.openapi._\n\nobject BooksEndpointExample extends ZIOAppDefault {\n  case class Book(\n    @description("Title of the book")\n    title: String,\n    @description("List of the authors of the book")\n    authors: List[String],\n  )\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  object BookRepo {\n    val book1 = Book("Programming in Scala", List("Martin Odersky", "Lex Spoon", "Bill Venners", "Frank Sommers"))\n    val book2 = Book("Zionomicon", List("John A. De Goes", "Adam Fraser"))\n    val book3 = Book("Effect-Oriented Programming", List("Bill Frasure", "Bruce Eckel", "James Ward"))\n    def find(q: String): List[Book] = {\n      if (q.toLowerCase == "scala") List(book1, book2, book3)\n      else if (q.toLowerCase == "zio") List(book2, book3)\n      else List.empty\n    }\n  }\n\n  val endpoint =\n    Endpoint((RoutePattern.GET / "books") ?? Doc.p("Route for querying books"))\n      .query(\n        HttpCodec.query[String]("q").examples(("example1", "scala"), ("example2", "zio")) ?? Doc.p(\n          "Query parameter for searching books",\n        ),\n      )\n      .out[List[Book]](Doc.p("List of books matching the query")) ?? Doc.p(\n      "Endpoint to query books based on a search query",\n    )\n\n  val booksRoute    = endpoint.implementHandler(handler((query: String) => BookRepo.find(query)))\n  val openAPI       = OpenAPIGen.fromEndpoints(title = "Library API", version = "1.0", endpoint)\n  val swaggerRoutes = SwaggerUI.routes("docs" / "openapi", openAPI)\n  val routes        = Routes(booksRoute) ++ swaggerRoutes\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n'))),(0,i.yg)("h2",{id:"generating-endpoint-from-openapi-spec"},"Generating Endpoint from OpenAPI Spec"),(0,i.yg)("p",null,"With ZIO HTTP, we can generate endpoints from an OpenAPI specification. To do this, first, we need to add the following line to the ",(0,i.yg)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-http-gen" % "3.0.1"\n')),(0,i.yg)("p",null,"Then we can generate the endpoints from the OpenAPI specification using the ",(0,i.yg)("inlineCode",{parentName:"p"},"EndpointGen.fromOpenAPI")," constructor:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/GenerateEndpointFromOpenAPIExample.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/GenerateEndpointFromOpenAPIExample.scala"'},'package example.endpoint\n\nimport java.nio.file._\n\nimport zio.http.endpoint.openapi.OpenAPI\nimport zio.http.gen.openapi.EndpointGen\nimport zio.http.gen.scala.CodeGen\n\nobject GenerateEndpointFromOpenAPIExample extends App {\n  val userOpenAPI = OpenAPI.fromJson(\n    """|{\n       |  "openapi": "3.0.0",\n       |  "info": {\n       |    "title": "User API",\n       |    "version": "1.0.0"\n       |  },\n       |  "paths": {\n       |    "/users/{userId}": {\n       |      "get": {\n       |        "parameters": [\n       |          {\n       |            "name": "userId",\n       |            "in": "path",\n       |            "required": true,\n       |            "schema": {\n       |              "type": "integer"\n       |            }\n       |          }\n       |        ],\n       |        "responses": {\n       |          "200": {\n       |            "content": {\n       |              "application/json": {\n       |                "schema": {\n       |                  "type": "object",\n       |                  "properties": {\n       |                    "userId": {\n       |                      "type": "integer"\n       |                    },\n       |                    "username": {\n       |                      "type": "string"\n       |                    }\n       |                  }\n       |                }\n       |              }\n       |            }\n       |          },\n       |          "404": {\n       |            "description": "User not found"\n       |          }\n       |        }\n       |      }\n       |    }\n       |  }\n       |}\n       |""".stripMargin,\n  )\n\n  CodeGen.writeFiles(\n    EndpointGen.fromOpenAPI(userOpenAPI.toOption.get),\n    basePath = Paths.get("./users/src/main/scala"),\n    basePackage = "org.example",\n    scalafmtPath = None,\n  )\n}\n')),(0,i.yg)("h2",{id:"generating-zio-cli-app-from-endpoint-api"},"Generating ZIO CLI App from Endpoint API"),(0,i.yg)("p",null,"The ZIO CLI is a ZIO library that provides a way to build command-line applications using ZIO facilities. With ZIO HTTP, we can generate a ZIO CLI client from the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API."),(0,i.yg)("p",null,"To do this, first, we need to add the following line to the ",(0,i.yg)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-http-cli" % "3.0.1"\n')),(0,i.yg)("p",null,"Then we can generate the ZIO CLI client from the ",(0,i.yg)("inlineCode",{parentName:"p"},"Endpoint")," API using the ",(0,i.yg)("inlineCode",{parentName:"p"},"HttpCliApp.fromEndpoints")," constructor:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'object TestCliApp extends zio.cli.ZIOCliDefault with TestCliEndpoints {\n  val cliApp =\n    HttpCliApp\n      .fromEndpoints(\n        name = "users-mgmt",\n        version = "0.0.1",\n        summary = HelpDoc.Span.text("Users management CLI"),\n        footer = HelpDoc.p("Copyright 2023"),\n        host = "localhost",\n        port = 8080,\n        endpoints = Chunk(getUser, getUserPosts, createUser),\n        cliStyle = true,\n      )\n      .cliApp\n}\n')),(0,i.yg)("p",null,"Using the above code, we can create the ",(0,i.yg)("inlineCode",{parentName:"p"},"users-mgmt")," CLI application that can be used to interact with the ",(0,i.yg)("inlineCode",{parentName:"p"},"getUser"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"getUserPosts"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"createUser")," endpoints:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-shell"},"                                                             __ \n  __  __________  __________      ____ ___  ____ _____ ___  / /_\n / / / / ___/ _ \\/ ___/ ___/_____/ __ `__ \\/ __ `/ __ `__ \\/ __/\n/ /_/ (__  )  __/ /  (__  )_____/ / / / / / /_/ / / / / / / /_  \n\\__,_/____/\\___/_/  /____/     /_/ /_/ /_/\\__, /_/ /_/ /_/\\__/  \n                                         /____/                 \n\nusers-mgmt v0.0.1 -- Users management CLI\n\nUSAGE\n\n  $ users-mgmt <command>\n\nCOMMANDS\n\n  - get-users --userId integer --location text                               Get a user by ID\n\n  - get-users-posts --postId integer --userId integer --user-name text       Get a user's posts by userId and postId\n\n  - create-users -f file|-u text|--.id integer --.name text [--.email text]  Create a new user\n\nCopyright 2023\n")),(0,i.yg)("details",null,(0,i.yg)("summary",null,(0,i.yg)("b",null,"Full Implementation Showcase")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/endpoint/CliExamples.scala"',title:'"zio-http-example/src/main/scala/example/endpoint/CliExamples.scala"'},'package example.endpoint\n\nimport zio._\nimport zio.cli._\n\nimport zio.schema._\nimport zio.schema.annotation.description\n\nimport zio.http.Header.Location\nimport zio.http._\nimport zio.http.codec._\nimport zio.http.endpoint.cli._\nimport zio.http.endpoint.{Endpoint, EndpointExecutor}\n\nfinal case class User(\n  @description("The unique identifier of the User")\n  id: Int,\n  @description("The user\'s name")\n  name: String,\n  @description("The user\'s email")\n  email: Option[String],\n)\nobject User {\n  implicit val schema: Schema[User] = DeriveSchema.gen[User]\n}\nfinal case class Post(\n  @description("The unique identifier of the User")\n  userId: Int,\n  @description("The unique identifier of the Post")\n  postId: Int,\n  @description("The post\'s contents")\n  contents: String,\n)\nobject Post {\n  implicit val schema: Schema[Post] = DeriveSchema.gen[Post]\n}\n\ntrait TestCliEndpoints {\n\n  val getUser =\n    Endpoint(Method.GET / "users" / int("userId") ?? Doc.p("The unique identifier of the user"))\n      .header(HeaderCodec.location ?? Doc.p("The user\'s location"))\n      .out[User] ?? Doc.p("Get a user by ID")\n\n  val getUserPosts =\n    Endpoint(\n      Method.GET /\n        "users" / int("userId") ?? Doc.p("The unique identifier of the user") /\n        "posts" / int("postId") ?? Doc.p("The unique identifier of the post"),\n    )\n      .query(\n        HttpCodec.query[String]("user-name") ?? Doc.p(\n          "The user\'s name",\n        ),\n      )\n      .out[List[Post]] ?? Doc.p("Get a user\'s posts by userId and postId")\n\n  val createUser =\n    Endpoint(Method.POST / "users")\n      .in[User]\n      .out[String] ?? Doc.p("Create a new user")\n}\n\nobject TestCliApp extends zio.cli.ZIOCliDefault with TestCliEndpoints {\n  val cliApp =\n    HttpCliApp\n      .fromEndpoints(\n        name = "users-mgmt",\n        version = "0.0.1",\n        summary = HelpDoc.Span.text("Users management CLI"),\n        footer = HelpDoc.p("Copyright 2023"),\n        host = "localhost",\n        port = 8080,\n        endpoints = Chunk(getUser, getUserPosts, createUser),\n        cliStyle = true,\n      )\n      .cliApp\n}\n\nobject TestCliServer extends zio.ZIOAppDefault with TestCliEndpoints {\n  val getUserRoute =\n    getUser.implementHandler {\n      Handler.fromFunctionZIO { case (id, _) =>\n        ZIO.succeed(User(id, "Juanito", Some("juanito@test.com"))).debug("Hello")\n      }\n    }\n\n  val getUserPostsRoute =\n    getUserPosts.implementHandler {\n      Handler.fromFunction { case (userId, postId, name) =>\n        List(Post(userId, postId, name))\n      }\n    }\n\n  val createUserRoute =\n    createUser.implementHandler {\n      Handler.fromFunction { user =>\n        user.name\n      }\n    }\n\n  val routes = Routes(getUserRoute, getUserPostsRoute, createUserRoute) @@ Middleware.debug\n\n  val run = Server.serve(routes).provide(Server.default)\n}\n\nobject TestCliClient extends zio.ZIOAppDefault with TestCliEndpoints {\n  val run =\n    clientExample\n      .provide(\n        EndpointExecutor.make(serviceName = "test"),\n        Client.default,\n      )\n\n  def clientExample: URIO[EndpointExecutor[Any, Unit], Unit] =\n    for {\n      executor <- ZIO.service[EndpointExecutor[Any, Unit]]\n      _        <- ZIO.scoped(executor(getUser(42, Location.parse("some-location").toOption.get))).debug("result1")\n      _        <- ZIO.scoped(executor(getUserPosts(42, 200, "adam")).debug("result2"))\n      _        <- ZIO.scoped(executor(createUser(User(2, "john", Some("john@test.com"))))).debug("result3")\n    } yield ()\n\n}\n'))))}c.isMDXComponent=!0}}]);