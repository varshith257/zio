"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[85009],{15680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>f});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||s;return n?a.createElement(f,r(r({ref:t},p),{},{components:n})):a.createElement(f,r({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var c=2;c<s;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},52284:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=n(58168),i=(n(96540),n(15680));const s={id:"clock",title:"TestClock"},r=void 0,o={unversionedId:"reference/test/services/clock",id:"reference/test/services/clock",title:"TestClock",description:"In most cases we want unit tests to be as fast as possible. Waiting for real time to pass by is a real killer for this.",source:"@site/docs/reference/test/services/clock.md",sourceDirName:"reference/test/services",slug:"/reference/test/services/clock",permalink:"/reference/test/services/clock",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/services/clock.md",tags:[],version:"current",frontMatter:{id:"clock",title:"TestClock"},sidebar:"reference-sidebar",previous:{title:"TestConsole",permalink:"/reference/test/services/console"},next:{title:"TestRandom",permalink:"/reference/test/services/random"}},l={},c=[{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Example 3",id:"example-3",level:3},{value:"Example 4",id:"example-4",level:3},{value:"Example 5",id:"example-5",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(d,(0,a.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"In most cases we want unit tests to be as fast as possible. Waiting for real time to pass by is a real killer for this."),(0,i.yg)("p",null,"ZIO exposes a ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock")," that can control the time. We can deterministically and efficiently ",(0,i.yg)("strong",{parentName:"p"},"test effects involving the passage of time")," without actually having to wait for the full amount of time to pass."),(0,i.yg)("p",null,"Calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," and methods derived from it will semantically block until the clock time is set/adjusted to on or after the time the effect is scheduled to run."),(0,i.yg)("p",null,"Instead of waiting for actual time to pass, ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," and methods implemented in terms of it schedule effects to take place at a given clock time. Users can adjust the clock time using the ",(0,i.yg)("inlineCode",{parentName:"p"},"adjust")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"setTime")," methods, and all effects scheduled to take place on or before that time will automatically be run in order."),(0,i.yg)("p",null,"For example, here is how we can test ",(0,i.yg)("inlineCode",{parentName:"p"},"ZIO#timeout")," using ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.test._\n\nfor {\n  fiber  <- ZIO.sleep(5.minutes).timeout(1.minute).fork\n  _      <- TestClock.adjust(1.minute)\n  result <- fiber.join\n} yield assertTrue(result.isEmpty)\n")),(0,i.yg)("p",null,"Note how we forked the fiber that ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," was invoked on. Calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," and methods derived from it will semantically block until the time is set to on or after the time they are scheduled to run."),(0,i.yg)("p",null,"If we didn't fork the fiber on which we called sleep we would never get to set the time on the line below. Thus, a useful pattern when using ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock")," is to fork the effect being tested, then adjust the clock time, and finally verify that the expected effects have been performed."),(0,i.yg)("p",null,"Clock time is just like a clock on the wall, except that in our ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock"),", the clock is broken. Instead of moving by itself, the clock time only changes when adjusted or set by the user, using the ",(0,i.yg)("inlineCode",{parentName:"p"},"adjust")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"setTime")," methods. The clock time never changes by itself."),(0,i.yg)("p",null,"When the clock is adjusted, any effects scheduled to run on or before the new clock time will automatically be run, in order."),(0,i.yg)("p",null,"For example, here is how we can test an effect that recurs with a fixed delay:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.Queue\nimport zio.test._\n\nfor {\n  q <- Queue.unbounded[Unit]\n  _ <- q.offer(()).delay(60.minutes).forever.fork\n  a <- q.poll.map(_.isEmpty)\n  _ <- TestClock.adjust(60.minutes)\n  b <- q.take.as(true)\n  c <- q.poll.map(_.isEmpty)\n  _ <- TestClock.adjust(60.minutes)\n  d <- q.take.as(true)\n  e <- q.poll.map(_.isEmpty)\n} yield assertTrue(a && b && c && d && e)\n")),(0,i.yg)("p",null,"Here we verify that no effect is performed before the recurrence period, that an effect is performed after the recurrence period, and that the effect is performed exactly once."),(0,i.yg)("p",null,"The key thing to note here is that after each recurrence the next recurrence is scheduled to occur at the appropriate time in the future, so when we adjust the clock by 60 minutes exactly one value is placed in the queue, and when we adjust the clock by another 60 minutes exactly one more value is placed in the queue."),(0,i.yg)("h2",{id:"examples"},"Examples"),(0,i.yg)("h3",{id:"example-1"},"Example 1"),(0,i.yg)("p",null,"Thanks to the call to ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock.adjust(1.minute)")," we moved the time instantly 1 minute."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\nimport java.util.concurrent.TimeUnit\nimport zio.Clock.currentTime\nimport zio.test.Assertion.isGreaterThanEqualTo\n\ntest("One can move time very fast") {\n  for {\n    startTime <- currentTime(TimeUnit.SECONDS)\n    _         <- TestClock.adjust(1.minute)\n    endTime   <- currentTime(TimeUnit.SECONDS)\n  } yield assertTrue((endTime - startTime) >= 60L)\n}\n')),(0,i.yg)("h3",{id:"example-2"},"Example 2"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"TestClock")," affects also all code running asynchronously that is scheduled to run after a certain time:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion.equalTo\n\ntest("One can control time as he see fit") {\n  for {\n    promise <- Promise.make[Unit, Int]\n    _       <- (ZIO.sleep(10.seconds) *> promise.succeed(1)).fork\n    _       <- TestClock.adjust(10.seconds)\n    readRef <- promise.await\n  } yield assertTrue(1 == readRef)\n}\n')),(0,i.yg)("p",null,'The above code creates a write-once cell that will be set to "1" after 10 seconds asynchronously from a different thread thanks to the call to ',(0,i.yg)("inlineCode",{parentName:"p"},"fork"),". In the end, we wait on the promise until it is set."),(0,i.yg)("p",null,"With the call to ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock.adjust(10.seconds)")," we simulate the passing of 10 seconds of time. Because of it, we don't need to wait for the real 10 seconds to pass and thus our unit test can run faster."),(0,i.yg)("p",null,"This is a pattern that will very often be used when ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock")," are being used for testing of effects that are based on time. The fiber that needs to sleep will be forked and ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock")," will used to adjust the time so that all expected effects are run in the forked fiber."),(0,i.yg)("h3",{id:"example-3"},"Example 3"),(0,i.yg)("p",null,"A more complex example leveraging dependencies and multiple services is shown below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test.Assertion._\nimport zio.test._\nimport zio.{test => _, _}\n\ntrait SchedulingService {\n  def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean]\n}\n\ntrait LoggingService {\n  def log(msg: String): ZIO[Any, Exception, Unit]\n}\n\nval schedulingLayer: ZLayer[LoggingService, Nothing, SchedulingService] =\n  ZLayer.fromFunction { (loggingService: LoggingService) =>\n    new SchedulingService {\n      def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean] =\n        (ZIO.sleep(10.seconds) *> promise.succeed(1))\n          .tap(b => loggingService.log(b.toString))\n    }\n}\n\ntest("One can control time for failing effects too") {\n  val failingLogger = ZLayer.succeed(new LoggingService {\n    override def log(msg: String): ZIO[Any, Exception, Unit] = ZIO.fail(new Exception("BOOM"))\n  })\n\n  val layer = failingLogger >>> schedulingLayer\n\n  val testCase =\n    for {\n      promise <- Promise.make[Unit, Int]\n      result <- ZIO.serviceWithZIO[SchedulingService](_.schedule(promise)).exit.fork\n      _ <- TestClock.adjust(10.seconds)\n      readRef <- promise.await\n      result <- result.join\n    } yield assertTrue((1 == readRef) && result.isFailure)\n  testCase.provideLayer(layer)\n}\n')),(0,i.yg)("p",null,"In this case, we want to test an effect with dependencies that can potentially fail with an error. To do this we need to run the effect and use assertions that expect an ",(0,i.yg)("inlineCode",{parentName:"p"},"Exit")," value."),(0,i.yg)("h3",{id:"example-4"},"Example 4"),(0,i.yg)("p",null,"The pattern with ",(0,i.yg)("inlineCode",{parentName:"p"},"Promise")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"await")," can be generalized when we need to wait for multiple values using a ",(0,i.yg)("inlineCode",{parentName:"p"},"Queue"),". We simply need to put multiple values into the queue and progress the clock multiple times and there is no need to create multiple promises."),(0,i.yg)("p",null,"Even if you have a non-trivial flow of data from multiple streams that can produce at different intervals and would like to test snapshots of data at a particular point in time ",(0,i.yg)("inlineCode",{parentName:"p"},"Queue")," can help with that."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{test, _}\nimport zio.stream._\nimport zio.test.Assertion.equalTo\n\ntest("zipLatest") {\n  val s1 = ZStream.iterate(0)(_ + 1).schedule(Schedule.fixed(100.milliseconds))\n  val s2 = ZStream.iterate(0)(_ + 1).schedule(Schedule.fixed(70.milliseconds))\n  val s3 = s1.zipLatest(s2)\n\n  for {\n    q      <- Queue.unbounded[(Int, Int)]\n    _      <- s3.foreach(q.offer).fork\n    fiber  <- ZIO.collectAll(ZIO.replicate(4)(q.take)).fork\n    _      <- TestClock.adjust(1.second)\n    result <- fiber.join\n  } yield assertTrue(result == List(0 -> 0, 0 -> 1, 1 -> 1, 1 -> 2))\n}\n')),(0,i.yg)("h3",{id:"example-5"},"Example 5"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"TestClock")," is used to speed up the tests by simulating the passage of time. This is useful for triggering scheduled effects, which is useful for testing time-dependent code. ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock")," does nothing to advance events on its own and is initialized to 00:00 1/1/70."),(0,i.yg)("p",null,"However, we can use a live clock to simulate events, enabling a fixed ratio of 'real' to 'test' time. ",(0,i.yg)("inlineCode",{parentName:"p"},"TestClock.adjust()")," can be used to advance time, but a real clock may be required to space out the advancements properly."),(0,i.yg)("p",null,"The test below creates a stream of 30 elements that are spaced 1 second apart. The test advances the clock by 1 second 30 times, allowing the stream to generate all 30 elements."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\n\ntest("test clock") {\n  val stream = ZStream.iterate(0)(_ + 1).schedule(Schedule.spaced(1.second))\n  val s1 = stream.take(30)\n  val sink = ZSink.collectAll[Int]\n  for {\n    fiber <- s1.run(sink).fork\n    _ <- TestClock.adjust(1.second).repeat(Schedule.recurs(30))\n    runner <- fiber.join\n  } yield assert(runner.size)(equalTo(30))\n}\n')),(0,i.yg)("p",null,"The test doesn't work because the fast forward is too fast and by the time the stream generator takes the first element, it has moved all the way to the end of the 30 seconds. We need to slow down the rate at which the test clock advances."),(0,i.yg)("p",null,"The problem is that the ",(0,i.yg)("inlineCode",{parentName:"p"},"Schedule")," needs a clock to do the spacing. We can't use the test clock since this is what we need to change. We opt to use the live clock instead with the ",(0,i.yg)("inlineCode",{parentName:"p"},"@@ withLiveClock")," test aspect. We also use ",(0,i.yg)("inlineCode",{parentName:"p"},"Schedule.spaced")," to dictate the spacing of the events in real time."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.stream._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\nimport zio.test.TestAspect._\n\n\ntest("live clock") {\n  val stream = ZStream.iterate(0)(_ + 1).schedule(Schedule.spaced(1.second))\n  val s1 = stream.take(30)\n  val sink = ZSink.collectAll[Int]\n  for {\n    fiber <- TestClock.adjust(1.second).repeat(Schedule.spaced(10.milliseconds)).fork\n    _ <- fiber.join\n    runner <- s1.run(sink)\n  } yield assert(runner.size)(equalTo(30))\n} @@ TestAspect.withLiveClock\n')),(0,i.yg)("p",null,"Using this technique, we can simulate the advancement of 1 second in the test clock for every 10 milliseconds in real time using the live clock."))}u.isMDXComponent=!0}}]);