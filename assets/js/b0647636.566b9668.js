"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[6447],{15680:(e,a,n)=>{n.d(a,{xA:()=>c,yg:()=>y});var t=n(96540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function p(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),o=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},c=function(e){var a=o(e.components);return t.createElement(s.Provider,{value:a},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=o(n),d=r,y=u["".concat(s,".").concat(d)]||u[d]||m[d]||i;return n?t.createElement(y,l(l({ref:a},c),{},{components:n})):t.createElement(y,l({ref:a},c))}));function y(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=d;var p={};for(var s in a)hasOwnProperty.call(a,s)&&(p[s]=a[s]);p.originalType=e,p[u]="string"==typeof e?e:r,l[1]=p;for(var o=2;o<i;o++)l[o]=n[o];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},36269:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>o});var t=n(58168),r=(n(96540),n(15680));const i={id:"cause",title:"Cause"},l=void 0,p={unversionedId:"reference/core/cause",id:"reference/core/cause",title:"Cause",description:"The ZIO[R, E, A] effect is polymorphic in values of type E and we can work with any error type that we want, but there is a lot of information that is not inside an arbitrary E value. So as a result ZIO needs somewhere to store things like unexpected errors or defects, stack and execution traces, cause of fiber interruptions, and so forth.",source:"@site/docs/reference/core/cause.md",sourceDirName:"reference/core",slug:"/reference/core/cause",permalink:"/reference/core/cause",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/core/cause.md",tags:[],version:"current",frontMatter:{id:"cause",title:"Cause"},sidebar:"reference-sidebar",previous:{title:"Exit",permalink:"/reference/core/exit"},next:{title:"Control Flow",permalink:"/reference/control-flow/"}},s={},o=[{value:"Cause Internals",id:"cause-internals",level:2},{value:"Cause Variations",id:"cause-variations",level:2},{value:"Empty",id:"empty",level:3},{value:"Fail",id:"fail",level:3},{value:"Die",id:"die",level:3},{value:"Interrupt",id:"interrupt",level:3},{value:"Stackless",id:"stackless",level:3},{value:"Both",id:"both",level:3},{value:"Then",id:"then",level:3}],c={toc:o},u="wrapper";function m(e){let{components:a,...n}=e;return(0,r.yg)(u,(0,t.A)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO[R, E, A]")," effect is polymorphic in values of type ",(0,r.yg)("inlineCode",{parentName:"p"},"E")," and we can work with any error type that we want, but there is a lot of information that is not inside an arbitrary ",(0,r.yg)("inlineCode",{parentName:"p"},"E")," value. So as a result ZIO needs somewhere to store things like ",(0,r.yg)("strong",{parentName:"p"},"unexpected errors or defects"),", ",(0,r.yg)("strong",{parentName:"p"},"stack and execution traces"),", ",(0,r.yg)("strong",{parentName:"p"},"cause of fiber interruptions"),", and so forth."),(0,r.yg)("p",null,"ZIO is very strict about preserving the full information related to a failure. It captures all type of errors into the ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause")," data type. ZIO uses ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause[E]")," to store the full story of failure, so its error model is ",(0,r.yg)("strong",{parentName:"p"},"lossless"),". It doesn't throw away information related to the failure result. So we can figure out exactly what happened during the operation of our effects."),(0,r.yg)("p",null,"It is important to note that ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause")," is the underlying data type for the ZIO data type, and we don't usually deal with it directly. Even though we do not deal with it very often, anytime we want, we can access the ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause")," data structure, which gives us total access to all parallel and sequential errors in our codebase."),(0,r.yg)("h2",{id:"cause-internals"},"Cause Internals"),(0,r.yg)("p",null,"ZIO uses a data structure from functional programming called a ",(0,r.yg)("em",{parentName:"p"},"semiring")," for the ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause")," data type. ",(0,r.yg)("strong",{parentName:"p"},"It allows us to take a base type ",(0,r.yg)("inlineCode",{parentName:"strong"},"E")," that represents the error type and then capture the sequential and parallel composition of errors in a fully lossless fashion"),"."),(0,r.yg)("p",null,"The following snippet shows how ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause")," is designed as a semiring data structure:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"sealed abstract class Cause[+E] extends Product with Serializable { self =>\n  import Cause._\n  def trace: Trace = ???\n\n  final def ++[E1 >: E](that: Cause[E1]): Cause[E1] = Then(self, that)\n  final def &&[E1 >: E](that: Cause[E1]): Cause[E1] = Both(self, that)\n}\n\nobject Cause extends Serializable {\n  case object Empty extends Cause[Nothing]\n  final case class Fail[+E](value: E, override val trace: Trace) extends Cause[E]\n  final case class Die(value: Throwable, override val trace: Trace) extends Cause[Nothing]\n  final case class Interrupt(fiberId: FiberId, override val trace: Trace) extends Cause[Nothing]\n  final case class Stackless[+E](cause: Cause[E], stackless: Boolean) extends Cause[E]\n  final case class Then[+E](left: Cause[E], right: Cause[E]) extends Cause[E]\n  final case class Both[+E](left: Cause[E], right: Cause[E]) extends Cause[E]\n}\n")),(0,r.yg)("p",null,"Using the ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause")," data structure described above, ZIO can capture all errors inside the application."),(0,r.yg)("h2",{id:"cause-variations"},"Cause Variations"),(0,r.yg)("p",null,"There are several causes for various errors. In this section, we will describe each of these causes. We will see how they can be created manually or how they will be automatically generated as the underlying error management data type of a ZIO application."),(0,r.yg)("h3",{id:"empty"},"Empty"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Empty")," cause indicates the lack of errors. We use ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause.empty")," constructor to create an ",(0,r.yg)("inlineCode",{parentName:"p"},"Empty")," cause. Using ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.failCause")," we can create a ZIO effect that has an empty cause:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nZIO.failCause(Cause.empty).cause.debug\n// Empty\n")),(0,r.yg)("p",null,"Also, we can use ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#cause")," to uncover the underlying cause of an effect. For example, we know that ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.succeed(5)")," has no errors. So, let's check that:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"ZIO.succeed(5).cause.debug\n// Empty\n\nZIO.attempt(5).cause.debug\n// Empty\n")),(0,r.yg)("h3",{id:"fail"},"Fail"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Fail")," cause indicates the cause of an ",(0,r.yg)("em",{parentName:"p"},"expected error")," of type ",(0,r.yg)("inlineCode",{parentName:"p"},"E"),". We can create one using the ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause.fail")," constructor:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.failCause(Cause.fail("Oh uh!")).cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646395282),Chunk(<empty>.MainApp.run(MainApp.scala:4))))\n')),(0,r.yg)("p",null,"Let's uncover the cause of some ZIO effects especially when we combine them:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.fail("Oh uh!").cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646395627),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n\n(ZIO.fail("Oh uh!") *> ZIO.dieMessage("Boom!") *> ZIO.interrupt).cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646396370),Chunk(<empty>.MainApp.run(MainApp.scala:6))))\n\n(ZIO.fail("Oh uh!") <*> ZIO.fail("Oh Error!")).cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646396419),Chunk(<empty>.MainApp.run(MainApp.scala:9))))\n\nval myApp: ZIO[Any, String, Int] =\n  for {\n    i <- ZIO.succeed(5)\n    _ <- ZIO.fail("Oh uh!")\n    _ <- ZIO.dieMessage("Boom!")\n    _ <- ZIO.interrupt\n  } yield i\nmyApp.cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646397126),Chunk(<empty>.MainApp.myApp(MainApp.scala:13),<empty>.MainApp.run(MainApp.scala:17))))\n')),(0,r.yg)("h3",{id:"die"},"Die"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Die")," cause indicates a defect, an ",(0,r.yg)("em",{parentName:"p"},"unexpected failure")," of type ",(0,r.yg)("inlineCode",{parentName:"p"},"Throwable"),". It contains the stack trace of the defect that occurred. We can use ",(0,r.yg)("inlineCode",{parentName:"p"},"Cause.die")," to create one:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.failCause(Cause.die(new Throwable("Boom!"))).cause.debug\n// Die(java.lang.Throwable: Boom!,Trace(Runtime(2,1646479908),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n')),(0,r.yg)("p",null,"If we have a bug in our code and something throws an unexpected exception, that information would be described inside a ",(0,r.yg)("inlineCode",{parentName:"p"},"Die"),". Let's try to investigate some ZIO code that will die:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.succeed(5 / 0).cause.debug\n// Die(java.lang.ArithmeticException: / by zero,Trace(Runtime(2,1646480112),Chunk(zio.internal.FiberContext.runUntil(FiberContext.scala:538),<empty>.MainApp.run(MainApp.scala:3))))\n\nZIO.dieMessage("Boom!").cause.debug\n// Stackless(Die(java.lang.RuntimeException: Boom!,Trace(Runtime(2,1646398246),Chunk(<empty>.MainApp.run(MainApp.scala:7)))),true)\n')),(0,r.yg)("p",null,"It is worth noting that the latest example is wrapped by the ",(0,r.yg)("inlineCode",{parentName:"p"},"Stackless")," cause in the previous example. We will discuss ",(0,r.yg)("inlineCode",{parentName:"p"},"Stackless")," further, but for now, it is enough to know that ",(0,r.yg)("inlineCode",{parentName:"p"},"Stackless")," includes fewer stack traces than the ",(0,r.yg)("inlineCode",{parentName:"p"},"Die")," cause."),(0,r.yg)("h3",{id:"interrupt"},"Interrupt"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Interrupt")," cause indicates a fiber interruption which contains information of the ",(0,r.yg)("em",{parentName:"p"},"fiber id")," of the interrupted fiber, and also the corresponding stack trace. Let's try an example of:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\n\nZIO.interrupt.cause.debug\n// Interrupt(Runtime(2,1646471715),Trace(Runtime(2,1646471715),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n\nZIO.never.fork\n  .flatMap(f => f.interrupt *> f.join)\n  .cause\n  .debug\n// Interrupt(Runtime(2,1646472025),Trace(Runtime(13,1646472025),Chunk(<empty>.MainApp.run(MainApp.scala:7))))\n")),(0,r.yg)("h3",{id:"stackless"},"Stackless"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Stackless")," cause stores stack traces and execution traces. It has a boolean ",(0,r.yg)("inlineCode",{parentName:"p"},"stackless")," flag which denotes whether the ZIO runtime should print the full stack trace of the inner cause or just print a few lines of it."),(0,r.yg)("p",null,"For example, ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.dieMessage")," uses ",(0,r.yg)("inlineCode",{parentName:"p"},"Stackless"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.dieMessage("Boom!").cause.debug\n// Stackless(Die(java.lang.RuntimeException: Boom!,Trace(Runtime(2,1646477970),Chunk(<empty>.MainApp.run(MainApp.scala:3)))),true)\n')),(0,r.yg)("p",null,"So when we run it the following stack traces will be printed:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-05T11:08:19.530710679Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.RuntimeException: Boom!\nat <empty>.MainApp.run(MainApp.scala:3)"\n')),(0,r.yg)("p",null,"While ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO.die")," doesn't use ",(0,r.yg)("inlineCode",{parentName:"p"},"Stackless")," cause:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nZIO.die(new Throwable("Boom!")).cause.debug\n// Die(java.lang.Exception: Boom!,Trace(Runtime(2,1646479093),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n')),(0,r.yg)("p",null,"So it prints the full stack trace:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-05T11:19:12.666418357Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.Exception: Boom!\n    at MainApp$.$anonfun$run$1(MainApp.scala:4)\n    at zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\n    at zio.internal.FiberContext.runUntil(FiberContext.scala:255)\n    at zio.internal.FiberContext.run(FiberContext.scala:115)\n    at zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n    at <empty>.MainApp.run(MainApp.scala:4)"\n')),(0,r.yg)("h3",{id:"both"},"Both"),(0,r.yg)("p",null,"When we are doing parallel computation, the effect can fail for more than one reason. If we are doing two things at once and both of them fail then we actually have two errors. So, the ",(0,r.yg)("inlineCode",{parentName:"p"},"Both")," cause stores the composition of two parallel causes."),(0,r.yg)("p",null,"For example, if we run two parallel fibers with ",(0,r.yg)("inlineCode",{parentName:"p"},"zipPar")," and all of them fail, their causes will be encoded with ",(0,r.yg)("inlineCode",{parentName:"p"},"Both"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval myApp: ZIO[Any, String, Unit] =\n  for {\n    f1 <- ZIO.fail("Oh uh!").fork\n    f2 <- ZIO.dieMessage("Boom!").fork\n    _ <- (f1 <*> f2).join\n  } yield ()\nmyApp.cause.debug\n// Both(Fail(Oh uh!,Trace(Runtime(13,1646481219),Chunk(<empty>.MainApp.myApp(MainApp.scala:5)))),Stackless(Die(java.lang.RuntimeException: Boom!,Trace(Runtime(14,1646481219),Chunk(<empty>.MainApp.myApp(MainApp.scala:6)))),true))\n')),(0,r.yg)("p",null,"If we run the ",(0,r.yg)("inlineCode",{parentName:"p"},"myApp")," effect, in the stack trace we can see two exception traces occurred on two separate fibers:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-05T12:37:46.831096692Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-13" java.lang.String: Oh uh!\nat <empty>.MainApp.myApp(MainApp.scala:5)\n  Exception in thread "zio-fiber-14" java.lang.RuntimeException: Boom!\n  at <empty>.MainApp.myApp(MainApp.scala:6)"\n')),(0,r.yg)("p",null,"Other parallel operators are also the same, for example, ZIO encodes the underlying cause of ",(0,r.yg)("inlineCode",{parentName:"p"},'(ZIO.fail("Oh uh!") <&> ZIO.dieMessage("Boom!"))')," with the ",(0,r.yg)("inlineCode",{parentName:"p"},"Both")," cause."),(0,r.yg)("h3",{id:"then"},"Then"),(0,r.yg)("p",null,"ZIO uses ",(0,r.yg)("inlineCode",{parentName:"p"},"Then")," cause to encode sequential errors. For example, if we perform ZIO's analog of ",(0,r.yg)("inlineCode",{parentName:"p"},"try-finally")," (e.g. ",(0,r.yg)("inlineCode",{parentName:"p"},"ZIO#ensuring"),"), and both ",(0,r.yg)("inlineCode",{parentName:"p"},"try")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"finally")," blocks fail, their causes are encoded with ",(0,r.yg)("inlineCode",{parentName:"p"},"Then"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\n\nval myApp =\n  ZIO.fail("first")\n    .ensuring(ZIO.die(throw new Exception("second")))\n\nmyApp.cause.debug\n// Then(Fail(first,Trace(Runtime(2,1646486975),Chunk(<empty>.MainApp.myApp(MainApp.scala:4),<empty>.MainApp.myApp(MainApp.scala:5),<empty>.MainApp.run(MainApp.scala:7)))),Die(java.lang.Exception: second,Trace(Runtime(2,1646486975),Chunk(zio.internal.FiberContext.runUntil(FiberContext.scala:538),<empty>.MainApp.myApp(MainApp.scala:5),<empty>.MainApp.run(MainApp.scala:7)))))\n')),(0,r.yg)("p",null,"If we run the ",(0,r.yg)("inlineCode",{parentName:"p"},"myApp")," effect, we can see the following stack trace:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'timestamp=2022-03-05T13:30:17.335173071Z level=ERROR thread=#zio-fiber-0 message="Exception in thread "zio-fiber-2" java.lang.String: first\n    at <empty>.MainApp.myApp(MainApp.scala:4)\n    at <empty>.MainApp.myApp(MainApp.scala:5)\n    Suppressed: java.lang.Exception: second\n        at MainApp$.$anonfun$myApp$3(MainApp.scala:5)\n        at zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\n        at zio.internal.FiberContext.runUntil(FiberContext.scala:255)\n        at zio.internal.FiberContext.run(FiberContext.scala:115)\n        at zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n        at zio.internal.FiberContext.runUntil(FiberContext.scala:538)\n        at <empty>.MainApp.myApp(MainApp.scala:5)"\n')),(0,r.yg)("p",null,"As we can see in the above stack trace, the ",(0,r.yg)("em",{parentName:"p"},"first")," failure was suppressed by the ",(0,r.yg)("em",{parentName:"p"},"second")," defect."))}m.isMDXComponent=!0}}]);