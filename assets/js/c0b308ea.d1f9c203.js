"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[12433],{15680:(e,n,o)=>{o.d(n,{xA:()=>d,yg:()=>g});var a=o(96540);function t(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function r(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,a)}return o}function i(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?r(Object(o),!0).forEach((function(n){t(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function s(e,n){if(null==e)return{};var o,a,t=function(e,n){if(null==e)return{};var o,a,t={},r=Object.keys(e);for(a=0;a<r.length;a++)o=r[a],n.indexOf(o)>=0||(t[o]=e[o]);return t}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)o=r[a],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(t[o]=e[o])}return t}var l=a.createContext({}),c=function(e){var n=a.useContext(l),o=n;return e&&(o="function"==typeof e?e(n):i(i({},n),e)),o},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},y=a.forwardRef((function(e,n){var o=e.components,t=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(o),y=t,g=p["".concat(l,".").concat(y)]||p[y]||m[y]||r;return o?a.createElement(g,i(i({ref:n},d),{},{components:o})):a.createElement(g,i({ref:n},d))}));function g(e,n){var o=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var r=o.length,i=new Array(r);i[0]=y;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:t,i[1]=s;for(var c=2;c<r;c++)i[c]=o[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,o)}y.displayName="MDXCreateElement"},26400:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=o(58168),t=(o(96540),o(15680));const r={id:"binary_codecs",title:"BinaryCodecs for Request/Response Bodies",sidebar_label:"BinaryCodecs"},i=void 0,s={unversionedId:"zio-http/reference/body/binary_codecs",id:"zio-http/reference/body/binary_codecs",title:"BinaryCodecs for Request/Response Bodies",description:"ZIO HTTP has built-in support for encoding and decoding request/response bodies. This is achieved using generating codecs for our custom data types powered by ZIO Schema.",source:"@site/docs/zio-http/reference/body/binary_codecs.md",sourceDirName:"zio-http/reference/body",slug:"/zio-http/reference/body/binary_codecs",permalink:"/zio-http/reference/body/binary_codecs",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/reference/body/binary_codecs.md",tags:[],version:"current",frontMatter:{id:"binary_codecs",title:"BinaryCodecs for Request/Response Bodies",sidebar_label:"BinaryCodecs"},sidebar:"ecosystem-sidebar",previous:{title:"Form Data",permalink:"/zio-http/reference/body/form"},next:{title:"Template",permalink:"/zio-http/reference/body/template"}},l={},c=[{value:"JSON Codec Example",id:"json-codec-example",level:2},{value:"JSON Serialization of Response Body",id:"json-serialization-of-response-body",level:3},{value:"JSON Deserialization of Request Body",id:"json-deserialization-of-request-body",level:3}],d={toc:c},p="wrapper";function m(e){let{components:n,...o}=e;return(0,t.yg)(p,(0,a.A)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("p",null,"ZIO HTTP has built-in support for encoding and decoding request/response bodies. This is achieved using generating codecs for our custom data types powered by ",(0,t.yg)("a",{parentName:"p",href:"https://zio.dev/zio-schema"},"ZIO Schema"),"."),(0,t.yg)("p",null,"ZIO Schema is a library for defining the schema for any custom data type, including case classes, sealed traits, and enumerations, other than the built-in types. It provides a way to derive codecs for these custom data types, for encoding and decoding data to/from JSON, Protobuf, Avro, and other formats."),(0,t.yg)("p",null,"Having codecs for our custom data types allows us to easily serialize/deserialize data to/from request/response bodies in our HTTP applications."),(0,t.yg)("p",null,"The ",(0,t.yg)("inlineCode",{parentName:"p"},"Body")," data type in ZIO HTTP represents the body message of a request or a response. It has two main functionality for encoding and decoding request/response bodies, both of which require an implicit ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec")," for the corresponding data type:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},(0,t.yg)("inlineCode",{parentName:"strong"},"Body#to[A]"))," \u2014 It decodes the request body to a custom data of type ",(0,t.yg)("inlineCode",{parentName:"li"},"A")," using the implicit ",(0,t.yg)("inlineCode",{parentName:"li"},"BinaryCodec")," for ",(0,t.yg)("inlineCode",{parentName:"li"},"A"),"."),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},(0,t.yg)("inlineCode",{parentName:"strong"},"Body.from[A]"))," \u2014 It encodes custom data of type ",(0,t.yg)("inlineCode",{parentName:"li"},"A")," to a response body using the implicit ",(0,t.yg)("inlineCode",{parentName:"li"},"BinaryCodec")," for ",(0,t.yg)("inlineCode",{parentName:"li"},"A"),".")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"trait Body {\n  def to[A](implicit codec: BinaryCodec[A]): Task[A] = ???\n}\n\nobject Body {\n  def from[A](a: A)(implicit codec: BinaryCodec[A]): Body = ???\n}\n")),(0,t.yg)("p",null,"To use these two methods, we need to have an implicit ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec")," for our custom data type, ",(0,t.yg)("inlineCode",{parentName:"p"},"A"),". Let's assume we have a ",(0,t.yg)("inlineCode",{parentName:"p"},"Book")," case class with ",(0,t.yg)("inlineCode",{parentName:"p"},"title"),", ",(0,t.yg)("inlineCode",{parentName:"p"},"authors")," fields:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"case class Book(title: String, authors: List[String])\n")),(0,t.yg)("p",null,"To create a ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec[Book]")," for our ",(0,t.yg)("inlineCode",{parentName:"p"},"Book")," case class, we can implement the ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec")," interface:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._ \nimport zio.stream._\nimport zio.schema.codec._\n\nimplicit val bookBinaryCodec = new BinaryCodec[Book] {\n  override def encode(value: Book): Chunk[Byte] = ???\n  override def streamEncoder: ZPipeline[Any, Nothing, Book, Byte] = ???\n  override def decode(whole: Chunk[Byte]): Either[DecodeError, Book] = ???\n  override def streamDecoder: ZPipeline[Any, DecodeError, Byte, Book] = ???\n}\n")),(0,t.yg)("p",null,"Now, when we call ",(0,t.yg)("inlineCode",{parentName:"p"},'Body.from(Book("Zionomicon", List("John De Goes")))'),", it will encode the ",(0,t.yg)("inlineCode",{parentName:"p"},"Book")," case class to a response body using the implicit ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec[Book]"),". But, what happens if we add a new field to the ",(0,t.yg)("inlineCode",{parentName:"p"},"Book")," case class, or change one of the existing fields? We would need to update the ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec[Book]")," implementation to reflect these changes. Also, if we want to support body response bodies with multiple book objects, we would need to implement a new codec for ",(0,t.yg)("inlineCode",{parentName:"p"},"List[Book]"),". So, maintaining these codecs can be cumbersome and error-prone."),(0,t.yg)("p",null,"ZIO Schema simplifies this process by providing a way to derive codecs for our custom data types. For each custom data type, ",(0,t.yg)("inlineCode",{parentName:"p"},"A"),", if we write/derive a ",(0,t.yg)("inlineCode",{parentName:"p"},"Schema[A]")," using ZIO Schema, then we can derive a ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec[A]")," for any format supported by ZIO Schema, including JSON, Protobuf, Avro, and Thrift."),(0,t.yg)("p",null,"So, let's generate a ",(0,t.yg)("inlineCode",{parentName:"p"},"Schema[Book]")," for our ",(0,t.yg)("inlineCode",{parentName:"p"},"Book")," case class:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.schema._\n\nobject Book {\n  implicit val schema: Schema[Book] = DeriveSchema.gen[Book]\n}\n")),(0,t.yg)("p",null,"Based on what format we want, we can add one of the following codecs to our ",(0,t.yg)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies += "dev.zio" %% "zio-schema-json"     % "1.4.1"\nlibraryDependencies += "dev.zio" %% "zio-schema-protobuf" % "1.4.1"\nlibraryDependencies += "dev.zio" %% "zio-schema-avro"     % "1.4.1"\nlibraryDependencies += "dev.zio" %% "zio-schema-thrift"   % "1.4.1"\n')),(0,t.yg)("p",null,"After adding the required codec's dependency, we can import the right binary codec inside the ",(0,t.yg)("inlineCode",{parentName:"p"},"zio.schema.codec")," package:"),(0,t.yg)("table",null,(0,t.yg)("thead",{parentName:"table"},(0,t.yg)("tr",{parentName:"thead"},(0,t.yg)("th",{parentName:"tr",align:null},"Codecs"),(0,t.yg)("th",{parentName:"tr",align:null},"Schema Based BinaryCodec (",(0,t.yg)("inlineCode",{parentName:"th"},"zio.schema.codec")," package)"),(0,t.yg)("th",{parentName:"tr",align:null},"Output"))),(0,t.yg)("tbody",{parentName:"table"},(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"JSON"),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"JsonCodec.schemaBasedBinaryCodec[A](implicit schema: Schema[A])")),(0,t.yg)("td",{parentName:"tr",align:null},"BinaryCodec","[A]")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"Protobuf"),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"ProtobufCodec.protobufCodec[A](implicit schema: Schema[A])")),(0,t.yg)("td",{parentName:"tr",align:null},"BinaryCodec","[A]")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"Avro"),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"AvroCodec.schemaBasedBinaryCodec[A](implicit schema: Schema[A])")),(0,t.yg)("td",{parentName:"tr",align:null},"BinaryCodec","[A]")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"Thrift"),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"ThriftCodec.thriftBinaryCodec[A](implicit schema: Schema[A])")),(0,t.yg)("td",{parentName:"tr",align:null},"BinaryCodec","[A]")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"MsgPack"),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"MessagePackCodec.messagePackCodec[A](implicit schema: Schema[A])")),(0,t.yg)("td",{parentName:"tr",align:null},"BinaryCodec","[A]")))),(0,t.yg)("p",null,"That is very simple! To have a ",(0,t.yg)("inlineCode",{parentName:"p"},"BinaryCodec")," of type ",(0,t.yg)("inlineCode",{parentName:"p"},"A")," we only need to derive a ",(0,t.yg)("inlineCode",{parentName:"p"},"Schema[A]")," and then use an appropriate codec from the ",(0,t.yg)("inlineCode",{parentName:"p"},"zio.schema.codec")," package."),(0,t.yg)("h2",{id:"json-codec-example"},"JSON Codec Example"),(0,t.yg)("h3",{id:"json-serialization-of-response-body"},"JSON Serialization of Response Body"),(0,t.yg)("p",null,"Assume want to write an HTTP API that returns a list of books in JSON format:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/codecs/ResponseBodyJsonSerializationExample.scala"',title:'"zio-http-example/src/main/scala/example/codecs/ResponseBodyJsonSerializationExample.scala"'},'package example.codecs\n\nimport zio._\n\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\n\nobject ResponseBodyJsonSerializationExample extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  val book1 = Book("Programming in Scala", List("Martin Odersky", "Lex Spoon", "Bill Venners", "Frank Sommers"))\n  val book2 = Book("Zionomicon", List("John A. De Goes", "Adam Fraser"))\n  val book3 = Book("Effect-Oriented Programming", List("Bill Frasure", "Bruce Eckel", "James Ward"))\n\n  val routes: Routes[Any, Nothing] =\n    Routes(\n      Method.GET / "users" ->\n        handler(Response(body = Body.from(List(book1, book2, book3)))),\n    )\n\n  def run = Server.serve(routes).provide(Server.default)\n}\n')),(0,t.yg)("h3",{id:"json-deserialization-of-request-body"},"JSON Deserialization of Request Body"),(0,t.yg)("p",null,"In the example below, we have an HTTP API that accepts a JSON request body containing a ",(0,t.yg)("inlineCode",{parentName:"p"},"Book")," object and adds it to a list of books:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/codecs/RequestBodyJsonDeserializationExample.scala"',title:'"zio-http-example/src/main/scala/example/codecs/RequestBodyJsonDeserializationExample.scala"'},'package example.codecs\n\nimport zio._\n\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\nimport zio.schema.{DeriveSchema, Schema}\n\nimport zio.http._\n\nobject RequestBodyJsonDeserializationExample extends ZIOAppDefault {\n\n  case class Book(title: String, authors: List[String])\n\n  object Book {\n    implicit val schema: Schema[Book] = DeriveSchema.gen\n  }\n\n  val routes: Routes[Ref[List[Book]], Nothing] =\n    Routes(\n      Method.POST / "books" ->\n        handler { (req: Request) =>\n          for {\n            book  <- req.body.to[Book].catchAll(_ => ZIO.fail(Response.badRequest("unable to deserialize the request")))\n            books <- ZIO.service[Ref[List[Book]]]\n            _     <- books.updateAndGet(_ :+ book)\n          } yield Response.ok\n        },\n      Method.GET / "books"  ->\n        handler { (_: Request) =>\n          ZIO\n            .serviceWithZIO[Ref[List[Book]]](_.get)\n            .map(books => Response(body = Body.from(books)))\n        },\n    )\n\n  def run = Server.serve(routes).provide(Server.default, ZLayer.fromZIO(Ref.make(List.empty[Book])))\n}\n')),(0,t.yg)("p",null,"To send a POST request to the ",(0,t.yg)("inlineCode",{parentName:"p"},"/books")," endpoint with a JSON body containing a ",(0,t.yg)("inlineCode",{parentName:"p"},"Book")," object, we can use the following ",(0,t.yg)("inlineCode",{parentName:"p"},"curl")," command:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-shell"},'$ curl -X POST -d \'{"title": "Zionomicon", "authors": ["John De Goes", "Adam Fraser"]}\' http://localhost:8080/books\n')),(0,t.yg)("p",null,"After sending the POST request, we can retrieve the list of books by sending a GET request to the ",(0,t.yg)("inlineCode",{parentName:"p"},"/books")," endpoint:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-shell"},"$ curl http://localhost:8080/books\n")))}m.isMDXComponent=!0}}]);