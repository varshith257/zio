"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[6508],{15680:(e,t,a)=>{a.d(t,{xA:()=>s,yg:()=>c});var n=a(96540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var m=n.createContext({}),g=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=g(e.components);return n.createElement(m.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,m=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),u=g(a),d=r,c=u["".concat(m,".").concat(d)]||u[d]||p[d]||l;return a?n.createElement(c,i(i({ref:t},s),{},{components:a})):n.createElement(c,i({ref:t},s))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=d;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var g=2;g<l;g++)i[g]=a[g];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},80977:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>g});var n=a(58168),r=(a(96540),a(15680));const l={id:"metrics",title:"Zio-Kafka Metrics"},i=void 0,o={unversionedId:"zio-kafka/metrics",id:"zio-kafka/metrics",title:"Zio-Kafka Metrics",description:"Zio-kafka exposes all the metrics of the wrapped Java based consumer and producer, plus some more metrics about the",source:"@site/docs/zio-kafka/metrics.md",sourceDirName:"zio-kafka",slug:"/zio-kafka/metrics",permalink:"/zio-kafka/metrics",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-kafka/metrics.md",tags:[],version:"current",frontMatter:{id:"metrics",title:"Zio-Kafka Metrics"},sidebar:"ecosystem-sidebar",previous:{title:"Partition Assignment And Offset Retrieval",permalink:"/zio-kafka/partition-assignment-and-offset-retrieval"},next:{title:"Tuning the consumer",permalink:"/zio-kafka/consumer-tuning"}},m={},g=[{value:"Java client metrics",id:"java-client-metrics",level:2},{value:"Zio-kafka consumer metrics",id:"zio-kafka-consumer-metrics",level:2},{value:"Poll metrics",id:"poll-metrics",level:3},{value:"Partition stream metrics",id:"partition-stream-metrics",level:3},{value:"Commit metrics",id:"commit-metrics",level:3},{value:"Aggregated commit metrics",id:"aggregated-commit-metrics",level:3},{value:"Rebalance metrics",id:"rebalance-metrics",level:3},{value:"Runloop metrics",id:"runloop-metrics",level:3}],s={toc:g},u="wrapper";function p(e){let{components:t,...a}=e;return(0,r.yg)(u,(0,n.A)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"Zio-kafka exposes all the metrics of the wrapped Java based consumer and producer, plus some more metrics about the\nzio-kafka consumer itself."),(0,r.yg)("h2",{id:"java-client-metrics"},"Java client metrics"),(0,r.yg)("p",null,"The metrics from the Java metrics can be obtained via the ",(0,r.yg)("inlineCode",{parentName:"p"},"Consumer.metrics")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"Producer.metrics")," methods. Both\nreturn a live view on the internal metrics of the consumer/producer. We currently do not expose these metrics elsewhere,\na PR to copy them to the zio-metrics API is welcome."),(0,r.yg)("h2",{id:"zio-kafka-consumer-metrics"},"Zio-kafka consumer metrics"),(0,r.yg)("p",null,"The zio-kafka consumer collects some additional metrics using the zio-metrics API. This allows any zio-metrics backend\nto access and process the observed values."),(0,r.yg)("p",null,"By default, no tags are added. Tags can be configured via ",(0,r.yg)("inlineCode",{parentName:"p"},"ConsumerSettings.withMetricsLabels"),"."),(0,r.yg)("p",null,"Like the zio-metrics we follow Prometheus conventions. This means that:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"durations are expressed in seconds,"),(0,r.yg)("li",{parentName:"ul"},"counters can only increase,"),(0,r.yg)("li",{parentName:"ul"},"metric names use snake_case and end in the unit where possible.")),(0,r.yg)("p",null,"The histograms each use 10 buckets. To reach a decent range while keeping sufficient accuracy at the low end, most\nbucket boundaries use an exponential series based on \ud835\udc52."),(0,r.yg)("h3",{id:"poll-metrics"},"Poll metrics"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counter"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_polls")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of polls.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_poll_latency_seconds")),(0,r.yg)("td",{parentName:"tr",align:null},"The duration of a single poll in seconds.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_poll_size")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of records fetched by a single poll.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"gauge"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_partitions_resumed_in_latest_poll")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of partitions resumed in the latest poll call.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"gauge"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_partitions_paused_in_latest_poll")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of partitions paused in the latest poll call (because of backpressure).")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counter"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_poll_auth_errors")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of polls that ended with an authentication or authorization error.")))),(0,r.yg)("h3",{id:"partition-stream-metrics"},"Partition stream metrics"),(0,r.yg)("p",null,"These metrics are updated after every poll."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_pending_requests")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of partitions that ran out of records (the queue is empty).")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_queue_size")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of records queued for a partition.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_all_queue_size")),(0,r.yg)("td",{parentName:"tr",align:null},"The total number of records queued for all partitions.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_queue_polls")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of polls during which records are idling in a queue.")))),(0,r.yg)("h3",{id:"commit-metrics"},"Commit metrics"),(0,r.yg)("p",null,"These metrics measure the separate commit requests issued through zio-kafka's api."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_pending_commits")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of commits that are awaiting completion.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counterInt"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_commits")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of commits.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_commit_latency_seconds")),(0,r.yg)("td",{parentName:"tr",align:null},"The duration of a commit in seconds.")))),(0,r.yg)("h3",{id:"aggregated-commit-metrics"},"Aggregated commit metrics"),(0,r.yg)("p",null,"After every poll zio-kafka combines all outstanding commit requests into 1 aggregated commit. These metrics are for the aggregated commits."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counterInt"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_aggregated_commits")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of aggregated commits.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_aggregated_commit_latency_seconds")),(0,r.yg)("td",{parentName:"tr",align:null},"The duration of an aggregated commit in seconds.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_aggregated_commit_size")),(0,r.yg)("td",{parentName:"tr",align:null},"An approximation of the number of records (offsets) per aggregated commit.")))),(0,r.yg)("h3",{id:"rebalance-metrics"},"Rebalance metrics"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counterInt"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_rebalances")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of rebalances.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"gauge"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_partitions_currently_assigned")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of partitions currently assigned to the consumer.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counterInt"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_partitions_assigned")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of partitions assigned to the consumer.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counterInt"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_partitions_revoked")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of partitions revoked to the consumer.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"counterInt"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_partitions_lost")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of partitions lost to the consumer.")))),(0,r.yg)("h3",{id:"runloop-metrics"},"Runloop metrics"),(0,r.yg)("p",null,"These metrics are updated after every poll."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Name"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"gauge"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_subscription_state")),(0,r.yg)("td",{parentName:"tr",align:null},"Whether the consumer is subscribed (1) or not (0).")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_command_queue_size")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of commands queued in the consumer.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"histogram"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"ziokafka_consumer_commit_queue_size")),(0,r.yg)("td",{parentName:"tr",align:null},"The number of commits queued in the consumer.")))),(0,r.yg)("p",null,"See ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/zio/zio-kafka/blob/master/zio-kafka/src/main/scala/zio/kafka/consumer/internal/ConsumerMetrics.scala"},"ConsumerMetrics.scala")," for the exact details."))}p.isMDXComponent=!0}}]);