"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[13194],{15680:(e,n,a)=>{a.d(n,{xA:()=>m,yg:()=>y});var t=a(96540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var c=t.createContext({}),l=function(e){var n=t.useContext(c),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},m=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=l(a),u=i,y=p["".concat(c,".").concat(u)]||p[u]||d[u]||r;return a?t.createElement(y,o(o({ref:n},m),{},{components:a})):t.createElement(y,o({ref:n},m))}));function y(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=a[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},95786:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var t=a(58168),i=(a(96540),a(15680));const r={id:"dynamic-data-representation",title:"Dynamic Data Representation"},o=void 0,s={unversionedId:"zio-schema/operations/dynamic-data-representation",id:"zio-schema/operations/dynamic-data-representation",title:"Dynamic Data Representation",description:"DynamicValue is a way to describe the entire universe of possibilities for schema values. It does that in a way that we can interact with and introspect the data with its structure (type information). The structure of the data is baked into the data itself.",source:"@site/docs/zio-schema/operations/dynamic-data-representation.md",sourceDirName:"zio-schema/operations",slug:"/zio-schema/operations/dynamic-data-representation",permalink:"/zio-schema/operations/dynamic-data-representation",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-schema/operations/dynamic-data-representation.md",tags:[],version:"current",frontMatter:{id:"dynamic-data-representation",title:"Dynamic Data Representation"},sidebar:"ecosystem-sidebar",previous:{title:"Schema Serialization",permalink:"/zio-schema/operations/schema-serialization"},next:{title:"Ordering Derivation",permalink:"/zio-schema/derivations/ordering-derivation"}},c={},l=[{value:"Schema: Converting to/from DynamicValue",id:"schema-converting-tofrom-dynamicvalue",level:2},{value:"Manipulating Dynamic Values",id:"manipulating-dynamic-values",level:2}],m={toc:l},p="wrapper";function d(e){let{components:n,...a}=e;return(0,i.yg)(p,(0,t.A)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"DynamicValue is a way to describe the entire universe of possibilities for schema values. It does that in a way that we can interact with and introspect the data with its structure (type information). The structure of the data is baked into the data itself."),(0,i.yg)("p",null,"We can create a ",(0,i.yg)("inlineCode",{parentName:"p"},"DynamicValue")," from a schema and a value using ",(0,i.yg)("inlineCode",{parentName:"p"},"DynamicValue.fromSchemaAndValue")," (or ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema#toDynamic"),"). We can turn it back into a typed value using ",(0,i.yg)("inlineCode",{parentName:"p"},"DynamicValue#toTypedValue"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait DynamicValue {\n  def toTypedValue[A](implicit schema: Schema[A]): Either[String, A] =\n}\n\nobject DynamicValue {\n  def fromSchemaAndValue[A](schema: Schema[A], value: A): DynamicValue\n}\n")),(0,i.yg)("p",null,"Let's create a simple instance of ",(0,i.yg)("inlineCode",{parentName:"p"},'Person("John Doe", 42)')," and convert it to ",(0,i.yg)("inlineCode",{parentName:"p"},"DynamicValue"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.schema._\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n}\n\nval person        = Person("John Doe", 42)\nval dynamicPerson = DynamicValue.fromSchemaAndValue(Person.schema, person)\n// or we can call `toDynamic` on the schema directly:\n// val dynamicPerson = Person.schema.toDynamic(person)\nprintln(dynamicPerson)\n')),(0,i.yg)("p",null,"As we can see, the dynamic value of ",(0,i.yg)("inlineCode",{parentName:"p"},"person")," is the mixure of the data and its structure:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"// The output pretty printed manually\nRecord(\n  Nominal(Chunk(dev,zio,quickstart),Chunk(),Person),\n  ListMap(\n    name -> Primitive(John Doe,string),\n    age -> Primitive(42,int)\n  )\n)\n")),(0,i.yg)("p",null,"This is in contrast to the relational database model, where the data structure is stored in the database schema and the data itself is stored in a separate location."),(0,i.yg)("p",null,"However, when we switch to document-based database models, such as JSON or XML, we can store both the data and its structure together. The JSON data model serves as a good example of self-describing data, as it allows us not only to include the data itself but also to add type information within the JSON. In this way, there is no need for a separate schema and data; everything is combined into a single entity."),(0,i.yg)("h2",{id:"schema-converting-tofrom-dynamicvalue"},"Schema: Converting to/from DynamicValue"),(0,i.yg)("p",null,"With a ",(0,i.yg)("inlineCode",{parentName:"p"},"Schema[A]"),", we can convert any value of type ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," to a ",(0,i.yg)("inlineCode",{parentName:"p"},"DynamicValue")," and conversely we can convert it back to ",(0,i.yg)("inlineCode",{parentName:"p"},"A"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait Schema[A] {\n  def toDynamic(value: A): DynamicValue\n\n  def fromDynamic(value: DynamicValue): scala.util.Either[String, A]\n}\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"toDynamic")," operation erases the type information of the value and places it into the value (the dynamic value) itself. The ",(0,i.yg)("inlineCode",{parentName:"p"},"fromDynamic")," operation does the opposite: it takes the type information from the dynamic value and uses it to reconstruct the original value."),(0,i.yg)("p",null,"Please note that, if we have two types ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"B")," that are isomorphic, we can convert a dynamic value of type ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," to a typed value of type ",(0,i.yg)("inlineCode",{parentName:"p"},"B")," and vice versa:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.schema._\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen\n}\n\ncase class User(name: String, age: Int)\n\nobject User {\n  implicit val schema: Schema[User] = DeriveSchema.gen\n}\n\nval johnPerson = Person("John Doe", 42)\nval johnUser   = User("John Doe", 42)\n\nval dynamicJohnPerson = Person.schema.toDynamic(johnPerson)\nval dynamicJohnUser   = User.schema.toDynamic(johnUser)\n\nprintln(dynamicJohnPerson)\n// Output: Record(Nominal(Chunk(dev,zio,quickstart),Chunk(Main),Person),ListMap(name -> Primitive(John Doe,string), age -> Primitive(42,int)))\nprintln(dynamicJohnUser)\n// Output: Record(Nominal(Chunk(dev,zio,quickstart),Chunk(Main),User),ListMap(name -> Primitive(John Doe,string), age -> Primitive(42,int)))\n\nassert(dynamicJohnPerson.toTypedValue[User] == Right(johnUser))\nassert(dynamicJohnUser.toTypedValue[Person] == Right(johnPerson))\n')),(0,i.yg)("h2",{id:"manipulating-dynamic-values"},"Manipulating Dynamic Values"),(0,i.yg)("p",null,"When we turn a typed value ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," into a ",(0,i.yg)("inlineCode",{parentName:"p"},"DynamicValue"),", we can manipulate its structure and data dynamically. For example, we can add a new field to a record or change the type of a field. This process is called dynamic value migration, which we will discuss in the ",(0,i.yg)("a",{parentName:"p",href:"/zio-schema/operations/schema-migration"},"schema migration")," section."))}d.isMDXComponent=!0}}]);